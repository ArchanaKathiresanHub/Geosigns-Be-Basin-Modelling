// Copyright 2014, Shell Global Solutions International B.V.
// All rights reserved. This document and the data and information contained herein is CONFIDENTIAL.
// Neither the whole nor any part of this document may be copied, modified or distributed in any
// form without the prior written consent of the copyright owner.

#include "NumericUtils.h"
#include "ParameterComponentTransforms.h"

#include <cassert>
#include <cmath>
#include <string>

namespace SUMlib
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// TrivialParameterTransform
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// apply
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double TrivialParameterTransform::apply( double original ) const
{
   return original;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// isValid
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool TrivialParameterTransform::isValid( std::string* /*reason*/ ) const
{
   return true;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LogParameterTransform
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
LogParameterTransform::LogParameterTransform( double parameterBoundMin, double parameterBoundMax ) :
   m_parScale( parameterBoundMax - parameterBoundMin ),
   m_parMin( parameterBoundMin )
{}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// apply
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double LogParameterTransform::apply( double original ) const
{
   double x = 0.5 * ( original + 1 ) * m_parScale;
   x += m_parMin;
   assert( x > 0 );
   x = log( x );
   return x;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// isValid
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool LogParameterTransform::isValid( std::string* reason ) const
{
   if ( m_parMin <= 0 )
   {
      if ( reason )
      {
         *reason += "Log transform not possible for values <= 0.";
      }
      return false;
   }
   return true;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// InverseParameterTransform
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
InverseParameterTransform::InverseParameterTransform( double parameterBoundMin, double parameterBoundMax ) :
   m_parScale( parameterBoundMax - parameterBoundMin ),
   m_parMin( parameterBoundMin )
{}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// apply
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double InverseParameterTransform::apply( double original ) const
{
   double x = 0.5 * ( original + 1 ) * m_parScale;
   x += m_parMin;
   assert( fabs( x ) > 0 );
   x = 1 / x;
   return x;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// isValid
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool InverseParameterTransform::isValid( std::string* reason ) const
{
   double parMax = m_parMin + m_parScale;
   if ( m_parMin < 0 && parMax > 0 || IsEqualTo( m_parMin, 0 ) || IsEqualTo( parMax, 0 ) )
   {
      if ( reason )
      {
         *reason += "Inverse transform not possible for values equal or 'very close' to 0.";
      }
      return false;
   }
   return true;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// SqrtParameterTransform
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SqrtParameterTransform::SqrtParameterTransform( double parameterBoundMin, double parameterBoundMax ) :
   m_parScale( parameterBoundMax - parameterBoundMin ),
   m_parMin( parameterBoundMin )
{}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// apply
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double SqrtParameterTransform::apply( double original ) const
{
   double x = 0.5 * ( original + 1 ) * m_parScale;
   x += m_parMin;
   assert( x >= 0 );
   x = sqrt( x) ;
   return x;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// isValid
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool SqrtParameterTransform::isValid( std::string* reason ) const
{
   if ( m_parMin < 0 )
   {
      if ( reason )
      {
         *reason += "Square root transform not possible for negative values.";
      }
      return false;
   }
   return true;
}

} /// namespace SUMlib
