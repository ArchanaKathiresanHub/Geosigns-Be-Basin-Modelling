//                                                                      
// Copyright (C) 2012-2014 Shell International Exploration & Production.
// All rights reserved.
// 
// Developed under license for Shell by PDS BV.
// 
// Confidential and proprietary source code of Shell.
// Do not distribute without written permission from Shell.
// 

#include "CasaCommander.h"
#include "CmdExpDataTxt.h"
#include "CmdEvaluateResponse.h"

#include "casaAPI.h"
#include "RunCase.h"

#include <cstdlib>
#include <iostream>
#include <fstream>
#include <iomanip>

using namespace casa;

CmdExpDataTxt::CmdExpDataTxt( CasaCommander & parent, const std::vector< std::string > & cmdPrms ) : CasaCmd( parent, cmdPrms )
{
   if ( m_prms.size() < 2 )
   {
      throw ErrorHandler::Exception( ErrorHandler::RSProxyError ) << "Wrong parameters number: " 
         << m_prms.size() << " (expected 2 or more) in data export command";
   }

   m_whatToSave   = m_prms[0];
   m_dataFileName = m_prms[1].empty() ? (m_whatToSave + ".dat") : m_prms[1];

   if ( m_whatToSave == "DoEParameters" )
   {
      // convert list of DoEs or data files like: "Tornado,BoxBenken" into array of names
      if ( m_prms.size() > 2 ) { m_expList = CfgFileParser::list2array( m_prms[2], ',' ); }
   }
   else if ( m_whatToSave == "RunCasesObservables" )
   {
      if ( m_prms.size() > 2 ) { m_expList = CfgFileParser::list2array( m_prms[1], ',' ); }
   }
   else if ( m_whatToSave == "ProxyEvalObservables" )
   {
      if ( m_prms.size() > 2 ) { m_expList = CfgFileParser::list2array( m_prms[2], ',' ); }
      if ( m_prms.size() > 3 ) { m_proxyName = m_prms[3]; }

      if ( m_proxyName.empty() ) throw ErrorHandler::Exception( ErrorHandler::UndefinedValue ) << "No proxy name was given";
   }
   else if ( m_whatToSave == "ProxyQC" )
   {
      if ( m_prms.size() > 2 ) { m_expList = CfgFileParser::list2array( m_prms[2], ',' ); }
      if ( m_prms.size() > 3 ) { m_proxyName = m_prms[3]; }

      if ( m_proxyName.empty() ) throw ErrorHandler::Exception( ErrorHandler::UndefinedValue ) << "No proxy name was given";
   }
   else if ( m_whatToSave == "MCResults" )
   {
      ;
   }
   else { throw ErrorHandler::Exception( ErrorHandler::RSProxyError ) << "Unknown command parameter: " <<  m_whatToSave; }
}

void CmdExpDataTxt::execute( std::auto_ptr<casa::ScenarioAnalysis> & sa )
{
   if ( m_commander.verboseLevel() > CasaCommander::Quiet )
   {
      std::cout << "Export CASA results to : " << m_dataFileName << std::endl;
   }

   if (      m_whatToSave == "DoEParameters"        ) { exportParameters( sa ); }
   else if ( m_whatToSave == "RunCasesObservables"  ) { exportRunCaseObs( sa ); } 
   else if ( m_whatToSave == "ProxyEvalObservables" ) { exportEvalObserv( sa ); }
   else if ( m_whatToSave == "ProxyQC"              ) { exportProxyQC(    sa ); }
   else if ( m_whatToSave == "MCResults"            ) { exportMCResults(  sa ); }
}

void CmdExpDataTxt::printHelpPage( const char * cmdName )
{
   std::cout << "  " << cmdName << " <what> <fileName> [<DoEList>] [<proxyName>]\n\n";
   std::cout << "  Export in plane txt file scenario data. This command goes over all run cases from the list of specified DoEs\n";
   std::cout << "  (if list wasn't specified - over all DoEs in scenario) and export numerical data for:\n";
   std::cout << "       DoEParameters       : generated by DoE parameters value\n";
   std::cout << "       RunCasesObservables : extracted from simulations observables value\n";
   std::cout << "       ProxyEvalObservables: evaluated from the given response surface observables value\n";
   std::cout << "       ProxyQC:              relation of simulated to evaluated observables value\n";
   std::cout << "       MCResults:            variable parameters and observables value from MC/MCMC simulation\n";

   std::cout << "  Where:\n";
   std::cout << "       what     - DoEParameters/RunCasesObservables/ProxyEvalObservables/ProxyQC\n";
   std::cout << "       fileName - file name to export data\n";
   std::cout << "       DoEList  - (Optional) comma separated list of DoEs name\n";
   std::cout << "       proxyName - must be defined for ProxyEvalObservables/ProxyQC. Proxy name which will be used to calculate observables value\n";
   std::cout << "\n";
   std::cout << "    Example:\n";
   std::cout << "    " << cmdName << " \"ProxyQC\" \"datafile.txt\"  \"FullFactorial,Tornado\" \"FirstOrderProxy\"\n";
   std::cout << "\n";
}

void CmdExpDataTxt::saveResults( const std::vector< std::vector<double> > & res )
{
   std::ofstream m_ofs;

   m_ofs.open( m_dataFileName.c_str(), std::ios_base::out | std::ios_base::trunc );

   if ( m_ofs.fail() ) throw ErrorHandler::Exception( ErrorHandler::IoError ) << "Can not open file for writing: " << m_dataFileName;


   for ( size_t i = 0; i < res.size(); ++i )
   {
      for ( size_t j = 0; j < res[i].size(); ++j )
      {
         m_ofs << std::scientific << std::setprecision( 8 )  << std::setfill( '0' ) << res[i][j] << " ";
      }
      m_ofs << std::endl;
   }
   m_ofs.close();
}


void CmdExpDataTxt::exportParameters( std::auto_ptr<casa::ScenarioAnalysis> & sa )
{
   if ( m_commander.verboseLevel() > CasaCommander::Quiet )
   {
      std::cout << "Export parameters value calculated by DoEs to " << m_dataFileName << std::endl;
   }

   casa::RunCaseSet & doeCaseSet = sa->doeCaseSet();
   std::vector<std::string> doeList = m_expList.empty() ? doeCaseSet.experimentNames() : m_expList;

   std::vector< std::vector<double> > results;

   for ( size_t e = 0; e < doeList.size(); ++e )
   {
      doeCaseSet.filterByExperimentName( doeList[e] );

      for ( size_t c = 0; c < doeCaseSet.size(); ++c )
      {
         results.push_back( std::vector<double>() );

         // go over all parameters 
         for ( size_t j = 0; j < doeCaseSet[c]->parametersNumber(); ++j )
         {
            const casa::Parameter * prm = doeCaseSet[c]->parameter( j ).get();

            switch ( prm->parent()->variationType() )
            {
               case casa::VarParameter::Continuous:
               case casa::VarParameter::Discrete:
                  {
                     const std::vector<double> & vals = prm->asDoubleArray();
                     results.back().insert( results.back().end(), vals.begin(), vals.end() );
                  }
                  break;

               case casa::VarParameter::Categorical:
                  results.back().push_back( prm->asInteger() );
                  break;
            }
         }
      }
   }
   saveResults( results );
}

void CmdExpDataTxt::exportRunCaseObs( std::auto_ptr<casa::ScenarioAnalysis> & sa )
{
   if ( m_commander.verboseLevel() > CasaCommander::Quiet )
   {
      std::cout << "Export observables value calculated in DoEs runs to " << m_dataFileName << std::endl;
   }

   casa::RunCaseSet & doeCaseSet = sa->doeCaseSet();
   std::vector<std::string> doeList = m_expList.empty() ? doeCaseSet.experimentNames() : m_expList;

   std::vector< std::vector<double> > results;

   for ( size_t e = 0; e < doeList.size(); ++e )
   {
      doeCaseSet.filterByExperimentName( doeList[e] );

      for ( size_t c = 0; c < doeCaseSet.size(); ++c )
      {
         results.push_back( std::vector<double>() );

         // go over all observables and extract values 
         for ( size_t j = 0; j < doeCaseSet[c]->observablesNumber(); ++j )
         {
            const casa::ObsValue * obsSim = doeCaseSet[c]->obsValue( j );

            if ( !obsSim->isDouble() ) continue;

            const std::vector<double> & valsSim = obsSim->asDoubleArray();
            results.back().insert( results.back().end(), valsSim.begin(), valsSim.end() );
         }
      }
   }
   saveResults( results );
}

void CmdExpDataTxt::exportEvalObserv( std::auto_ptr<casa::ScenarioAnalysis> & sa )
{
   if ( m_commander.verboseLevel() > CasaCommander::Quiet )
   {
      std::cout << "Export observables value for response surface proxy " << m_proxyName << " to " << m_dataFileName << std::endl;
   }

   std::vector<std::string> doeList = m_expList.empty() ? sa->doeCaseSet().experimentNames() : m_expList;

   std::vector<casa::RunCase *> rcs; // set of run cases which were created from set of parameters defined in external dat file
   std::vector<size_t> casePerExp;
  
   CmdEvaluateResponse::createRunCasesSet( sa, rcs, doeList, casePerExp ); // create new set of run cases with parameters value

   // Search for given proxy name in the set of calculated proxies
   casa::RSProxy * proxy = sa->rsProxySet().rsProxy( m_proxyName.c_str() );
   // call response evaluation
   if ( !proxy ) { throw ErrorHandler::Exception( ErrorHandler::NonexistingID ) << "Unknown proxy name:" << m_proxyName; }

   std::vector< std::vector<double> > results( rcs.size() );

   size_t i = 0;
   for ( size_t e = 0; e < doeList.size(); ++e )
   {
      if ( m_commander.verboseLevel() > CasaCommander::Quiet )
      {
         std::cout << " evaluate proxy for " << doeList[e]  << "DoE for " << casePerExp[e]  << " cases\n";
      }
      
      for ( size_t c = 0; c < casePerExp[e]; ++c )
      {
         assert( i < rcs.size() );

         if ( ErrorHandler::NoError != proxy->evaluateRSProxy( *rcs[i] ) )
         {
            throw ErrorHandler::Exception( proxy->errorCode() ) << proxy->errorMessage();
         }

         // go over all observables and calculate PrxVal for each observable
         for ( size_t j = 0; j < rcs[i]->observablesNumber(); ++j )
         {
            const casa::ObsValue * obsPrx = rcs[i]->obsValue( j );

            if ( !obsPrx->isDouble() ) continue;

            const std::vector<double> & valsPrx = obsPrx->asDoubleArray();
            results[i].insert( results[i].end(), valsPrx.begin(), valsPrx.end() );
         }
         ++i;
      }
   }
   saveResults( results );

}

void CmdExpDataTxt::exportProxyQC( std::auto_ptr<casa::ScenarioAnalysis> & sa )
{
   if ( m_commander.verboseLevel() > CasaCommander::Quiet )
   {
      std::cout << "Export QC data for response surface proxy " << m_proxyName << " to " << m_dataFileName << std::endl;
   }

   casa::RunCaseSet & doeCaseSet = sa->doeCaseSet();
   std::vector<std::string> doeList = m_expList.empty() ? doeCaseSet.experimentNames() : m_expList;

   std::vector<casa::RunCase *> rcs; // set of run cases which were created from set of parameters defined in external dat file
   std::vector<size_t> casePerExp;
  
   CmdEvaluateResponse::createRunCasesSet( sa, rcs, doeList, casePerExp ); // create new set of run cases with parameters value

   // Search for given proxy name in the set of calculated proxies
   casa::RSProxy * proxy = sa->rsProxySet().rsProxy( m_proxyName.c_str() );
   // call response evaluation
   if ( !proxy ) { throw ErrorHandler::Exception( ErrorHandler::NonexistingID ) << "Unknown proxy name:" << m_proxyName; }

   std::vector< std::vector<double> > results( rcs.size() );

   size_t i = 0;
   for ( size_t e = 0; e < doeList.size(); ++e )
   {
      if ( m_commander.verboseLevel() > CasaCommander::Quiet )
      {
         std::cout << " evaluate proxy for " << doeList[e]  << "DoE for " << casePerExp[e]  << " cases\n";
      }
      
      doeCaseSet.filterByExperimentName( doeList[e] );

      for ( size_t c = 0; c < casePerExp[e]; ++c )
      {
         assert( i < rcs.size() );

         if ( ErrorHandler::NoError != proxy->evaluateRSProxy( *rcs[i] ) )
         {
            throw ErrorHandler::Exception( proxy->errorCode() ) << proxy->errorMessage();
         }

         // go over all observables and calculate PrxVal/SimVal for each observable
         for ( size_t j = 0; j < rcs[i]->observablesNumber(); ++j )
         {
            const casa::ObsValue * obsPrx = rcs[i]->obsValue( j );
            const casa::ObsValue * obsSim = doeCaseSet[c]->obsValue( j );

            if ( !obsPrx->isDouble() || !obsSim->isDouble() ) continue;

            const std::vector<double> & valsPrx = obsPrx->asDoubleArray();
            const std::vector<double> & valsSim = obsSim->asDoubleArray();

            assert( valsSim.size() == valsPrx.size() );

            for ( size_t k = 0; k < valsPrx.size(); ++k )
            {
               double rel = std::abs( valsSim[k] ) < 1e-20 ? ( std::abs( valsPrx[k] ) < 1e-20 ? 1.0 : UndefinedDoubleValue ) :
                                                             ( valsPrx[k] / valsSim[k] );
               results[i].push_back( rel );
            }
         }
         ++i;
      }
   }
   saveResults( results );
}
         
void CmdExpDataTxt::exportMCResults( std::auto_ptr<casa::ScenarioAnalysis> & sa )
{
   if ( m_commander.verboseLevel() > CasaCommander::Quiet )
   {
      std::cout << "Export MC/MCMC to " << m_dataFileName << std::endl;
   }

   std::vector< std::vector<double> > results;
   // export MC samples
   const MonteCarloSolver::MCResults & mcSamples = sa->mcSolver().getSimulationResults();

   for ( size_t i = 0; i < mcSamples.size(); ++i )
   {
      results.push_back( std::vector<double>() );
      
      std::vector<double> & rsmpl = results.back();
      rsmpl.push_back( static_cast<double>( i ) );                //sample num
      rsmpl.push_back(mcSamples[i].first); //sample RMSE

      // sample parameters set
      for ( size_t j = 0; j < mcSamples[i].second->parametersNumber(); ++j )
      {
         SharedParameterPtr prm = mcSamples[i].second->parameter( j );

         switch( prm->parent()->variationType() )
         {
            case VarParameter::Continuous:
            case VarParameter::Discrete:
               {
                  const std::vector<double> & prmVals = prm->asDoubleArray();
                  for ( size_t k = 0; k < prmVals.size(); ++k ) { rsmpl.push_back( prmVals[k] ); }
               }
               break;

            case VarParameter::Categorical:  rsmpl.push_back( static_cast<double>( prm->asInteger() ) );  break;
            default: assert( false ); break;
         }
      }
      // observables values set
      for ( size_t j = 0; j < mcSamples[i].second->observablesNumber(); ++j )
      {
         ObsValue * obv = mcSamples[i].second->obsValue( j );

         if ( obv && obv->isDouble() )
         {
            const std::vector<double> & vals = obv->asDoubleArray();
            for ( size_t k = 0; k < vals.size(); ++k ) rsmpl.push_back( vals[k] );
         }
      }
   }
   saveResults( results );
}
