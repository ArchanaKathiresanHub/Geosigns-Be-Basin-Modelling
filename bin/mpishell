#!/bin/csh
#
# Purpose: to allow programs using MPICH & ssh to access their environment variables
#
# Restrictions: This script is only intended to work for MPICH.
#
# Description: MPICH programs using ssh to spawn jobs have the problem that the 
# users environment variables are not available to executables spawned by ssh. 
# This is true even when the users  ~/.ssh/rc script has been defined and executed. 
# The purpose of this script is to create another script containg the users 
# environment as it was when it was called. This script is then submitted to 
# MPICH with the mpirun command.
#
# Syntax: mpishell <mpich_option> ... -- <executable> <executable_option> ...
# mpich_option      - parameters passed to mpirun command
# --                - used to indicate the end of mpirun options
# executable        - the mpich executable to be run (uses PATH to find it)
# executable_option - program arguments
#
# Environment Variables:
#   DEBUG - when defined generates additional messages
#
# Dependencies:
# - Linux  - currently the only platform using MPICH.
# - MPICH  - mpirun will be found using the PATH. 
# - ssh    - it is assumed that the authorization details have been taken care of 
#          (RSA/DSA keys have been created for the servers used).
#
# Notes:
# 1. This script creates a temporary file mpishell-XXXXXX.ssh (where XXXXXX is a
# random number) in the current working directory. 
# 2. This script is used by each remote ssh process to define the environment 
# variables.
# 3. The script will not be deleted if the DEBUG flag is on or an error has 
# occurred during  execution.
# 4. Will only work when the current working directory is accessable to all 
# of the machines where it will be run.
#
# To Do:
#
###############################################################################

###############################################################################
#
# make my file creation friendly
#
umask 0

###############################################################################
#
# get and check parameters
#
if ( ${#argv} < 3 ) then
	echo "Usage $0 <mpich option> [<mpich option> ...] -- <executable> [<argument> ...]"
	exit 1
endif

# only run this command on Linux servers
if ( $CSCE_ARCH != LinuxRHEL64_x86_64 ) then
	echo "  Error! This command can only be run from a Linux platform."
	exit 1
endif 


###############################################################################
#
# define a unique name of the script to be created
#
set myfile = `pwd`/`mktemp mpishell-XXXXXX`
set myscript = ${myfile}.ssh
if [ -f $myfile ] then
    rm -f $myfile
endif
if [ -f $myscript ] then
    rm -f $myscript
endif

###############################################################################
#
# parse the arguments to get:
#   number of CPU's, machine file name, and command to run
#
set state = MPI
set mpi_opts = ""
set exec_opts = ""
while ( ${#argv} > 0 )

    if ( $?DEBUG ) then
	echo "Parsing options, state = ${state}, opt = $1"
    endif

    switch ( $state )
    case MPI:
	if ( "$1" == "--" ) then
	    set state = EXEC
	else
	    set mpi_opts = "$mpi_opts $1"
	endif
	breaksw

    case EXEC:
	set exec = `which $1`
	set result = $?
	if ( "$result" != 0 ) then
	    echo "Error unknown executable $exec"
	    exit 1
	endif
	set state = ARGS
	breaksw

    case ARGS:
	set exec_opts = "$exec_opts $1"
	breaksw
    endsw
    shift
end

# if command was found locally ('.') then replace with the pathname
if ( `echo $exec | awk -F'/' '{ print $1 }'` == "." ) then
    set executable = `pwd`/`echo $exec | awk -F'/' '{ print $2 }'`
else
    set executable = $exec
endif

###############################################################################
#
# dump the users environment to a script that defines environment and runs command
#
# will check for Korn or Bourne, otherwise assumes a c-shell
# Actually, it does not matter what shell is used.
#
echo -n '#!' > $myfile
echo "$SHELL" >> $myfile
if ( $SHELL == /bin/sh || $SHELL == /usr/bin/sh ) then
    env | sed 's/=/="/' | sed 's/$/"/' | awk -F'=' '{ print $0; printf("export %s\n", $1);}'>> $myfile
else if ( $SHELL == /bin/ksh || $SHELL == /usr/bin/ksh ) then
    env | sed 's/^/export /' | sed 's/=/="/' | sed 's/$/"/' >> $myfile
else
    env | sed 's/^/setenv /' | sed 's/=/ "/' | sed 's/$/"/' >> $myfile
endif

if ( $?DEBUG ) then
    echo -n 'echo "    `hostname`($$): ' >>$myfile
    echo -n "Starting $exec " >>$myfile
    echo '$*"' >>$myfile
endif

# generate command
echo -n "$executable " >>$myfile
echo '$*' >>$myfile

if ( $?DEBUG ) then
    echo -n 'echo "    `hostname`($$): ' >>$myfile
    echo -n "$exec returned " >>$myfile 
    echo '$?"' >>$myfile
endif

###############################################################################
#
# copy file to script, add execution mode
#
cp -f $myfile $myscript
rm -f $myfile
chmod +x $myscript
#sleep 3

###############################################################################
#
# start the script up using MPICH
#
if ( $?DEBUG ) then
    echo "Starting mpirun $mpi_opts $myscript $exec_opts"
endif
 
mpirun $mpi_opts $myscript $exec_opts
set result = $?

# tell them what happened
if ( $?DEBUG ) then
    echo "mpirun complete, returned $result"
else if ( $result == 0 ) then
    rm -f $myscript
endif

exit $result
