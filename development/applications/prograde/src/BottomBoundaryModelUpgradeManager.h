//
// Copyright (C) 2018-2018 Shell International Exploration & Production.
// All rights reserved.
//
// Developed under license for Shell by CGI
//
// Confidential and proprietary source code of Shell.
// Do not distribute without written permission from Shell.
//

#ifndef PROGRADE_BOTTOM_BOUNDARY_MODEL_UPGRADE_MANAGER_H
#define PROGRADE_BOTTOM_BOUNDARY_MODEL_UPGRADE_MANAGER_H

//Prograde
#include "IUpgradeManager.h"
#include <memory>
namespace mbapi {
	class Model;
}

namespace DataAccess {
	namespace Interface {
		class ProjectHandle;
	}
}
namespace DataAccess {
	namespace Interface {
		class GridMap;
	}
}

namespace Prograde
{
	/// @class BottomBoundaryModelUpgradeManager  is an inteface provided for handling all the upgrades related to any of the legacy bottom boundary models
	
	class BottomBoundaryModelUpgradeManager  : public IUpgradeManager {

	public:
		BottomBoundaryModelUpgradeManager(std::string name, mbapi::Model& model);
		virtual ~BottomBoundaryModelUpgradeManager(void) {};

	protected:

		void upgrade() {};

		//@brief checks if the specified map for a property (propName) of any single record IoTbl (tableName) falls within the acceptable limit bounded by [lowerLimit, higherLimit]. 
		//       Also checks if the corresponding scalar value for that property is also specified. If both map and scalar are specified then setting the scalar value to -9999 keeping the map only.  
		//	     Another point to note that for most the fields for which grid is available, scalar is also available. So at the same time we are also checking for the scalar value if map is not defined for that property.
		void checkRangeForMaps(const std::string & tableName, const std::string & propName, double lowerLimit, double higherLimit);

		//@brief Checking whether the original/legacy inputs of any Age-Property table are acceptable in BPA2 or not... 
		//@details If the property is specified as a scalar and its value is out of the acceptable limit (allowedMinValue,allowedMaxValue)->clip the value to its nearest limit and make it visible in the log file
		//		   If the property is specified as a map and the min and max of that map is out of the acceptable limit (allowedMinValue,allowedMaxValue)->No alteration in the map values but making this visible in the log file
		void preProcessingInput(const std::string tableName, const std::string propertyName, double allowedMinValue, double allowedMaxValue);

		//@brief It will check whether the bottom boundary history needs to be generated by linear interpolation or not. 
		//@details  If the oldest bottom boundary history age is younger than the basinAge => No interpolation needed. Generate the history @basinAge by constant extrapolation of nearest value
		//			If the oldest bottom boundary history age is older than the basinAge =>
		//				-> basinAge is already available in the table => No interpolation is needed.
		//				-> basinAge is not available in the table  => Interpolation is needed and also gives the bounading ages needed for interpolation.
		bool findInterpolatingAges(const std::string tableName, const std::string propertyName, const double basinAge, double& interpolatingLowerAge, double& interpolatingHigherAge);

		//@brief Generate a new map at basinAge by lineraly interpolating the values defined at interpolatingLowerAge and interpolatingHigherAge 
		DataAccess::Interface::GridMap* generateInterpolatedMapAtAge(std::string bottomBoundaryModel, bool needInterpolation, const double basinAge, double& interpolatingLowerAge, double& interpolatingHigherAge);

		//@brief save the newly generated interpolated map in the inputs.hdf. If the map is having only constant value then save it as a scalar instead of a map. Also refer the map in the GridMapIoTbl 
		void saveInterpolatedMap(DataAccess::Interface::GridMap* gridmap, const std::string tableName, const size_t rowIndex, const std::string propertyName, const double basinAge);

		//records older than the basin age specified in the bottom boundary model tables are not used in the simulation...hence removed from the input p3d file
		void removeRecordsOlderThanBasinAge(const std::string & tableName, const double basinAge);
		
		//@brief Clear tables which are not applicable to a particular bottom boundary model
		bool cleartables(std::string tableName);

		//@brief map references from the GridMapIotbl must have to be removed if the deleted tables under ClearTables(...) function contains any map. Otherwise Import will through an error.
		void removeRecordsFromGridMapIoTbl(bool isRemoved, std::string tableName);

		//virtual bool CheckDefaultValues(const std::string & tableName, const std::string & fieldName, const double bpa2DefaultValue) = 0;

		virtual void updateTableValue(const std::string & tableName, const std::string & fieldName, const double bpa2DefaultValue);

		//@brief Checks if the fieldName of the tableName has default values of BPA2 or not. If is not having the default value then make it visible in the log. No update of the value is done.
		bool CheckDefaultValues(const std::string & tableName, const std::string & fieldName, const double bpa2DefaultValue);


		mbapi::Model& m_model; ///< The model to upgrade
		std::shared_ptr<DataAccess::Interface::ProjectHandle> m_ph; ///< The project handle of the model to upgrade
	
	};
}

#endif

