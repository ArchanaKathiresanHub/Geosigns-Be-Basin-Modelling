//
// Copyright (C) 2012-2014 Shell International Exploration & Production.
// All rights reserved.
//
// Developed under license for Shell by PDS BV.
//
// Confidential and proprietary source code of Shell.
// Do not distribute without written permission from Shell.
//

/// @file ScenarioAnalysis.C
/// This file keeps methods definition for ScenarioAnalysis class

// CASA
#include "casaAPI.h"
#include "cmbAPI.h"

#include "DataDiggerImpl.h"
#include "DoEGeneratorImpl.h"
#include "MonteCarloSolverImpl.h"
#include "LMOptAlgorithm.h"
#include "ObsSpaceImpl.h"
#include "ObsGridPropertyXYZ.h"
#include "ObsGridPropertyWell.h"
#include "ObsValueDoubleArray.h"
#include "ObsValueDoubleScalar.h"
#include "RSProxyImpl.h"
#include "RSProxySetImpl.h"
#include "RunCaseImpl.h"
#include "RunCaseSetImpl.h"
#include "RunManagerImpl.h"
#include "SensitivityCalculatorImpl.h"
#include "SUMlibUtils.h"
#include "CasaSerializer.h"
#include "CasaDeserializer.h"
#include "VarSpaceImpl.h"
#include "PrmWindow.h"
#include "PrmLithoFraction.h"

// Utilities lib
#include <NumericFunctions.h>

#include "FolderPath.h"
#include "FilePath.h"

// STL
#include <fstream>
#include <set>
#include <sstream>
#include <string>
#include <utility>

// Standard C lib
#include <cassert>
#include <cmath>
#include <map>

namespace casa
{

///////////////////////////////////////////////////////////////////////////////////////////////
// Class which hides all ScenarioAnalysis implementation
class ScenarioAnalysis::ScenarioAnalysisImpl
{
public:
   // Constructor / destructor
   ScenarioAnalysisImpl();

   ~ScenarioAnalysisImpl();

   // Define scenario ID
   void defineScenarioID( const char * scID ) { m_scenarioID = std::string( scID ); }

   // Get scenario ID
   const char * scenarioID() { return m_scenarioID.c_str(); }

   // Define a base case for scenario analysis from file.
   void defineBaseCase( const char * projectFileName );

   // get base case project file name
   const char * baseCaseProjectFileName() const { return m_baseCaseProjectFile.c_str(); }

   // Get base case model if it was set, empty model otherwise
   mbapi::Model & baseCase();

   // Get RunCase for the base case project
   RunCase * baseCaseRunCase() { return m_baseCaseRunCase.get(); }

   // Set path where SA will generate a bunch of cases
   void setScenarioLocation(const char * pathToCaseSet , const bool append = false);

   // Get path to top level folder where the set of generated cases are located
   const char *scenarioLocation() const { return m_caseSetPath.c_str(); }

   // Provide influential parameters set manager
   VarSpace & varSpace() { return *m_varSpace; }

   // Define DoE algorithm. This function should be called before accessing to the instance of DoEGenerator
   // algo Type of DoE algorithm
   // return ErrorHandler::NoError in case of success, or error code otherwise
   void setDoEAlgorithm( DoEGenerator::DoEAlgorithm algo );

   // Get reference to instance of DoE generator which will be used in scenario analysis. If algorithm
   // wasn't set before by ScenarioAnalysis::setDoEAlgorithm(), the DoEGenerator::Tornado algorithm will be chosen.
   // return reference to the DoEGenerator instance.
   DoEGenerator * doeGenerator();

   // Get all cases for this scenario. The list will include cases generated by DoE only
   // return reference to casa::RunCaseSet object
   RunCaseSet & doeCaseSet() { return *m_doeCases; }

   // Create copy of the base case model and set all influential parameters value defined for each case
   void applyMutations( RunCaseSet & cs, const bool append );

   // @brief Get scenario iteration number. Iteration number is used to avoid overlapping projects folder.
   size_t scenarioIteration() const { return m_iterationNum; }

   // Extract 1D projects around the wells with a user-defined window size
   void extractOneDProjects( const std::string & expLabel );

   // Import 1D results and make the averages
   void importOneDResults( const std::string & expLabel );

   // Set one filter for selecting the parameters from 1D optimizations
   void setFilterOneDResults( const std::string & filterAlgorithm );

   // The parameter filter
   bool parameterFilter( Parameter * prm, RunCase * rc );

   // Generate 3D result project file from  1D cases
   void generateThreeDFromOneD( const std::string & expLabel, const int smoothingMethod, const double smoothingRadius, const int nrOfThreads );

   // Validate Cauldron model for consistency and valid parameters range. This function should be
   // called after ScenarioAnalysis::applyMutation()
   void validateCaseSet( RunCaseSet & cs );

   // Get run manager associated with this scenario analysis
   // return reference to the instance of run manager
   RunManager & runManager() { return *m_runManager; }

   // Recreate run manager
   void resetRunManager( bool cleanApps ) { m_runManager->resetState( cleanApps ); }

   // Get data digger associated with this scenario analysis
   // return reference to the instance of data digger
   DataDigger & dataDigger() { return *m_dataDigger; }

   // Get list of observables for this scenario
   // return Observables set manager
   ObsSpace & obsSpace() { return *m_obsSpace; }

   // Define which order of response surface polynomial approximation of  will be used in this scenario analysis
   // order order of polynomial approximation
   // krType do we need Kriging interpolation, and which one?
   void addRSAlgorithm(const std::string & name, const int order, RSProxy::RSKrigingType krType, const std::vector<std::string> & doeList );

   // Creates response surface proxy of given name based on provided polynomical order, and kriging type
   RSProxy * createRSProxy( const std::string & name, const int order, RSProxy::RSKrigingType krType );

   // Calculates observables on existing response surface proxy for given doe list
   void calculateRSProxy( RSProxy * proxy, const std::vector<const RunCase *> & runCases ) const;

   // Get response surface proxies set
   RSProxySet & rsProxySet() { return *m_rsProxySet; }

   // Get all cases for this scenario. The list will include cases generated by MC/MCMC only
   RunCaseSet & mcCaseSet() { return *m_mcCases; }

   // Define type of Monte Carlo algorithm which will be used in this scenario analysis
   // algo Monte Carlo algorithm
   // interp do we need Kriging interpolation? If yes, the response surface proxy must also use it.
   void setMCAlgorithm( MonteCarloSolver::Algorithm algo
                      , MonteCarloSolver::KrigingType kr
                      , MonteCarloSolver::PriorDistribution priorDist
                      , MonteCarloSolver::MeasurementDistribution measureDist
                      )
   {
      m_mcSolver.reset( new MonteCarloSolverImpl( algo, kr, priorDist, measureDist ) );
   }

   // Get Monte Carlo solver
   // return reference to Monte Carlo solver. If MC solver algorithm wasn't defined befor by ScenarioAnalysis::setMCAlgorithm(), it
   //         will be set up to MC with no Kriging by default.
   MonteCarloSolver & mcSolver()  { return *m_mcSolver; }

   // Save best matched case from Monte Carlo solver as calibrated scenario
   void saveCalibratedCase( const char * projFileName, size_t mcSampleNum );

   // Run given optimization algorithm and store calibration results to the given projet file
   void calibrateProjectUsingOptimizationAlgorithm( const std::string & cbProjectName
                                                  , const std::string & optimAlg
                                                  , ScenarioAnalysis  & sa
                                                  , bool                keepHistory
                                                  , const std::string & transformation
                                                  , const double        relativeReduction
                                                  );

   // Get SensitivityCalculator
   SensitivityCalculator & sensitivityCalculator() { return *m_sensCalc; }

   // Dump ScenarioAnalysis object to file
   void serialize( CasaSerializer & outStream );

   // Load ScenarioAnalysis object from file
   void deserialize( CasaDeserializer & inStream );

   // To copy run case from one scenarion to another
   std::shared_ptr<RunCaseImpl> copyAnotherScenarioCase( const std::shared_ptr<RunCase> cs );

private:
   std::string                                m_scenarioID;          // scenario ID, some id which will be mentioned in all generated files
   std::string                                m_caseSetPath;         // path to folder which will be the root folder for all scenario cases
   std::string                                m_baseCaseProjectFile; // path to the base case project file
   int                                        m_iterationNum;        // Scenario analysis iteration number
   int                                        m_caseNum;             // counter for the cases, used in folder name of the case
   std::vector<double>                        m_xcoordOneD;          // x coordinates of the extracted wells for multi 1D
   std::vector<double>                        m_ycoordOneD;          // y coordinates of the extracted wells for multi 1D
   int                                        m_filteringAlgorithm;  // The filtering algorithm

   std::unique_ptr<mbapi::Model>          m_baseCase;
   std::unique_ptr<RunCase>               m_baseCaseRunCase;    // run case for the base case project
   std::unique_ptr<ObsSpace>              m_obsSpace;           // observables manager
   std::unique_ptr<VarSpace>              m_varSpace;           // influential parameters manager
   std::unique_ptr<DoEGenerator>          m_doe;

   std::unique_ptr<RunCaseSet>            m_doeCases;
   std::unique_ptr<RunCaseSet>            m_mcCases;

   std::unique_ptr<RunManager>            m_runManager;
   std::unique_ptr<DataDigger>            m_dataDigger;
   std::unique_ptr<RSProxySet>            m_rsProxySet;
   std::unique_ptr<SensitivityCalculator> m_sensCalc;
   std::unique_ptr<MonteCarloSolver>      m_mcSolver;
};

///////////////////////////////////////////////////////////////////////////////
// Set of ScenarioAnalysis wrapper functions to hide the actual implementation from .h

// Constructor / destructor
ScenarioAnalysis::ScenarioAnalysis()  { m_pimpl.reset( new ScenarioAnalysisImpl() ); }
ScenarioAnalysis::~ScenarioAnalysis() { m_pimpl.reset( 0 ); }

// One line methods
mbapi::Model          & ScenarioAnalysis::baseCase()                { return m_pimpl->baseCase();              } // get scenario base case
RunCase               * ScenarioAnalysis::baseCaseRunCase()         { return m_pimpl->baseCaseRunCase();       } // get base case project run case
VarSpace              & ScenarioAnalysis::varSpace()                { return m_pimpl->varSpace();              } // Get scenario influential parameters
ObsSpace              & ScenarioAnalysis::obsSpace()                { return m_pimpl->obsSpace();              } // Get scenario observables
RunCaseSet            & ScenarioAnalysis::doeCaseSet()              { return m_pimpl->doeCaseSet();            } // Get set of cases generated by DoE
RunManager            & ScenarioAnalysis::runManager()              { return m_pimpl->runManager();            }
DataDigger            & ScenarioAnalysis::dataDigger()              { return m_pimpl->dataDigger();            }
RSProxySet            & ScenarioAnalysis::rsProxySet()              { return m_pimpl->rsProxySet();            }
RunCaseSet            & ScenarioAnalysis::mcCaseSet()               { return m_pimpl->mcCaseSet();             }
MonteCarloSolver      & ScenarioAnalysis::mcSolver()                { return m_pimpl->mcSolver();              }
SensitivityCalculator & ScenarioAnalysis::sensitivityCalculator()   { return m_pimpl->sensitivityCalculator(); }
const char            * ScenarioAnalysis::scenarioID()              { return m_pimpl->scenarioID();            }
size_t                  ScenarioAnalysis::scenarioIteration() const { return m_pimpl->scenarioIteration();     }
void                    ScenarioAnalysis::resetRunManager(bool cleanApps ) { m_pimpl->resetRunManager( cleanApps ); }

RSProxy * ScenarioAnalysis::createRSProxy( const std::string      & name
                                         , const int                order
                                         , RSProxy::RSKrigingType   krType
                                         )
{
  return m_pimpl->createRSProxy(name, order, krType);
}

// Define Scenario ID
ErrorHandler::ReturnCode ScenarioAnalysis::defineScenarioID( const char * scID )
{
   if ( !scID ) { return this->ErrorHandler::reportError( OutOfRangeValue, "Empty scenario ID" ); }
   m_pimpl->defineScenarioID( scID );

   return NoError;
}

// Define base case form cauldron project file
ErrorHandler::ReturnCode ScenarioAnalysis::defineBaseCase( const char * projectFileName )
{
   try { m_pimpl->defineBaseCase( projectFileName ); }
   catch( Exception & ex ) { return reportError( ex.errorCode(), ex.what() ); }
   catch( ...            ) { return reportError( UnknownError, "Unknown error" ); }

   return NoError;
}

const char * ScenarioAnalysis::baseCaseProjectFileName() const
{
   return m_pimpl->baseCaseProjectFileName();
}

// set path where scenario will generate projects
ErrorHandler::ReturnCode ScenarioAnalysis::setScenarioLocation( const char * pathToCaseSet, const bool append )
{
   try { m_pimpl->setScenarioLocation( pathToCaseSet, append ); }
   catch ( Exception & ex           ) { return reportError( ex.errorCode(), ex.what() ); }
   catch ( ibs::PathException & pex ) { return reportError( IoError,        pex.what() ); }
   catch ( ...                      ) { return reportError( UnknownError,   "Unknown error" ); }

   return NoError;
}

const char * ScenarioAnalysis::scenarioLocation() const
{
   return m_pimpl->scenarioLocation();
}

// Define DoE algorithm
ErrorHandler::ReturnCode ScenarioAnalysis::setDoEAlgorithm( DoEGenerator::DoEAlgorithm algo )
{
   try { m_pimpl->setDoEAlgorithm( algo ); }
   catch ( Exception & ex ) { return reportError( ex.errorCode(), ex.what() ); }
   catch ( ... ) { return reportError( UnknownError, "Unknown error" ); }

   return NoError;
}


// Get DoE generator
DoEGenerator & ScenarioAnalysis::doeGenerator()
{
   if ( !m_pimpl->doeGenerator() )
   {
      m_pimpl->setDoEAlgorithm( DoEGenerator::Tornado );
   }
   return *( m_pimpl->doeGenerator() );
}


// Apply mutations and generate project files for the set of cases from DoE
ErrorHandler::ReturnCode ScenarioAnalysis::applyMutations(RunCaseSet & cs , const bool append)
{
   try { m_pimpl->applyMutations( cs, append ); }
   catch ( Exception & ex           ) { return reportError( ex.errorCode(), ex.what()  ); }
   catch ( ibs::PathException & pex ) { return reportError( IoError,        pex.what() ); }
   catch ( ...                      ) { return reportError( UnknownError,   "Unknown error" ); }

   return NoError;
}

ErrorHandler::ReturnCode ScenarioAnalysis::extractOneDProjects( const std::string & expLabel )
{
   try { m_pimpl->extractOneDProjects( expLabel ); }
   catch ( Exception          & ex  ) { return reportError( ex.errorCode(), ex.what()  ); }
   catch ( ibs::PathException & pex ) { return reportError( IoError,        pex.what() ); }
   catch ( ...                      ) { return reportError(UnknownError,    "Unknown error"); }

   return NoError;

}

ErrorHandler::ReturnCode ScenarioAnalysis::importOneDResults( const std::string & expLabel )
{
   try { m_pimpl->importOneDResults( expLabel ); }
   catch ( Exception          & ex ) { return reportError( ex.errorCode(), ex.what() ); }
   catch ( ibs::PathException & pex ) { return reportError( IoError, pex.what() ); }
   catch ( ... ) { return reportError( UnknownError, "Unknown error" ); }

   return NoError;

}

ErrorHandler::ReturnCode ScenarioAnalysis::setFilterOneDResults( const std::string & filterAlgorithm )
{
   try { m_pimpl->setFilterOneDResults( filterAlgorithm ); }
   catch ( Exception          & ex ) { return reportError( ex.errorCode( ), ex.what( ) ); }
   catch ( ibs::PathException & pex ) { return reportError( IoError, pex.what( ) ); }
   catch ( ... ) { return reportError( UnknownError, "Unknown error" ); }

   return NoError;
}


ErrorHandler::ReturnCode ScenarioAnalysis::generateThreeDFromOneD( const std::string & expLabel, const int smoothingMethod,
                                                                   const double smoothingRadius, const int nrOfThreads )
{
   try { m_pimpl->generateThreeDFromOneD( expLabel, smoothingMethod, smoothingRadius, nrOfThreads ); }
   catch ( Exception          & ex ) { return reportError( ex.errorCode( ), ex.what( ) ); }
   catch ( ibs::PathException & pex ) { return reportError( IoError, pex.what( ) ); }
   catch ( ... ) { return reportError( UnknownError, "Unknown error" ); }

   return NoError;
}

ErrorHandler::ReturnCode ScenarioAnalysis::validateCaseSet( RunCaseSet & cs )
{
   try { m_pimpl->validateCaseSet( cs ); }
   catch( Exception & ex ) { return reportError( ex.errorCode(), ex.what() ); }
   catch( ...            ) { return reportError( UnknownError, "Unknown error" ); }

   return NoError;
}


ErrorHandler::ReturnCode ScenarioAnalysis::addRSAlgorithm( const char * name
                                                         , const int order
                                                         , RSProxy::RSKrigingType krType
                                                         , const std::vector<std::string> & doeList
                                                         )
{
   try { m_pimpl->addRSAlgorithm( name, order, krType, doeList ); }
   catch( Exception & ex ) { return reportError( ex.errorCode(), ex.what() ); }
   catch( ...            ) { return reportError( UnknownError, "Unknown error" ); }

   return NoError;
}

ErrorHandler::ReturnCode ScenarioAnalysis::setMCAlgorithm( MonteCarloSolver::Algorithm               algo
                                                         , MonteCarloSolver::KrigingType             interp
                                                         , MonteCarloSolver::PriorDistribution       priorDist
                                                         , MonteCarloSolver::MeasurementDistribution measureDist
                                                         )
{
   try { m_pimpl->setMCAlgorithm( algo, interp, priorDist, measureDist ); }
   catch( Exception & ex ) { return reportError( ex.errorCode(), ex.what() ); }
   catch( ...            ) { return reportError( UnknownError, "Unknown error" ); }

   return NoError;
}

ErrorHandler::ReturnCode ScenarioAnalysis::calibrateProjectUsingOptimizationAlgorithm( const std::string & cbProjeName
                                                                                     , const std::string & optimAlg
                                                                                     , const std::string & transformation
                                                                                     , const double        relativeReduction
                                                                                     , bool                keepHistory
                                                                                     )
{
   try { m_pimpl->calibrateProjectUsingOptimizationAlgorithm( cbProjeName, optimAlg, *this, keepHistory, transformation, relativeReduction ); }
   catch( Exception & ex ) { return reportError( ex.errorCode(), ex.what() ); }
   catch( ...            ) { return reportError( UnknownError, "Unknown error" ); }

   return NoError;
}


ErrorHandler::ReturnCode ScenarioAnalysis::saveCalibratedCase( const char * projFileName, size_t mcSampleNum )
{
   try { m_pimpl->saveCalibratedCase( projFileName, mcSampleNum ); }
   catch( Exception & ex ) { return reportError( ex.errorCode(), ex.what() ); }
   catch( ...            ) { return reportError( UnknownError, "Unknown error" ); }

   return NoError;
}


// Save scenario to the file
ErrorHandler::ReturnCode ScenarioAnalysis::saveScenario( const char * fileName, const char * fileType )
{
   try
   {
      std::unique_ptr<CasaSerializer> outStream( CasaSerializer::createSerializer( fileName, fileType, version() ) );
      m_pimpl->serialize( *(outStream.get()) );
   }
   catch ( const ErrorHandler::Exception & ex ) { return reportError( ex.errorCode(),     ex.what() ); }
   catch ( const std::exception          & ex ) { return reportError( SerializationError, ex.what() ); }

   return NoError;
}

// Create new ScenarioAnaylysis object and read all data from the given file
ScenarioAnalysis * ScenarioAnalysis::loadScenario( const char * fileName, const char * fileType )
{
   ScenarioAnalysis * sc( new ScenarioAnalysis() );
   try
   {
      std::ifstream fid;

      if (      !fileType || !strlen( fileType ) || !strcmp( "bin", fileType ) ) { fid.open( fileName, std::ios::binary ); }
      else if (                                     !strcmp( "txt", fileType ) ) { fid.open( fileName ); }
      else
      {
         throw Exception( NonexistingID ) << "Unknown type of input file for loading ScenarioAnalysis object: " << fileType;
      }

      if ( !fid.good() ) throw Exception(DeserializationError) << "Can not open file: " << fileName << " for reading";

      std::unique_ptr<CasaDeserializer> inStream( CasaDeserializer::createDeserializer( fid, fileType, sc->version() ) );

      sc->m_pimpl->deserialize( *inStream );
      if ( sc->errorCode() != ErrorHandler::NoError ) { throw ErrorHandler::Exception( sc->errorCode() ) << sc->errorMessage(); }
      }
   catch ( const ErrorHandler::Exception & ex ) { sc->reportError( ex.errorCode(), ex.what() ); }

   return sc;
}

// Create new ScenarioAnaylysis object and read all data from the given file
ScenarioAnalysis * ScenarioAnalysis::loadScenario( const char * stateFileBuf, size_t bufSize, const char * fileType )
{
   ScenarioAnalysis * sc( new ScenarioAnalysis() );
   try
   {
      std::string inpStr( stateFileBuf, bufSize );
      std::istringstream fid( inpStr );

      if ( !fid.good() ) throw Exception( DeserializationError ) << "Can not read from the given memory buffer";

      std::unique_ptr<CasaDeserializer> inStream( CasaDeserializer::createDeserializer( fid
                                                                                    , fileType == NULL ? "" : std::string( fileType )
                                                                                    , sc->version()
                                                                                    ) );
      sc->m_pimpl->deserialize( *inStream );
      if ( sc->errorCode() != ErrorHandler::NoError )
      {
         throw ErrorHandler::Exception( sc->errorCode() ) << sc->errorMessage();
      }
   }
   catch ( const ErrorHandler::Exception & ex ) { sc->reportError( ex.errorCode(), ex.what() ); }

   return sc;
}


///////////////////////////////////////////////////////////////////////////////
// The actual implementation of CASA API
ScenarioAnalysis::ScenarioAnalysisImpl::ScenarioAnalysisImpl()
{
   m_iterationNum = 1;
   m_caseNum      = 1;
   m_caseSetPath = ".";
   m_scenarioID = "Undefined";
   m_filteringAlgorithm = 0;

   m_varSpace.reset(   new VarSpaceImpl()   );
   m_obsSpace.reset(   new ObsSpaceImpl()   );

   m_doeCases.reset(   new RunCaseSetImpl() );
   m_mcCases.reset(    new RunCaseSetImpl() );

   m_runManager.reset( new RunManagerImpl() );
   m_dataDigger.reset( new DataDiggerImpl() );

   m_rsProxySet.reset( new RSProxySetImpl() );

   m_mcSolver.reset(   new MonteCarloSolverImpl()   );
   m_sensCalc.reset(   new SensitivityCalculatorImpl( m_varSpace.get(), m_obsSpace.get() ) );
}

ScenarioAnalysis::ScenarioAnalysisImpl::~ScenarioAnalysisImpl()
{
}

void ScenarioAnalysis::ScenarioAnalysisImpl::defineBaseCase( const char * projectFileName )
{
   if ( m_baseCase.get() )
   {
      m_baseCase.reset( NULL );
   }

   m_baseCaseProjectFile = projectFileName;
}

mbapi::Model & ScenarioAnalysis::ScenarioAnalysisImpl::baseCase()
{
   if ( !m_baseCase.get() )
   {
      if ( m_baseCaseProjectFile.empty() ) throw Exception( ErrorHandler::UndefinedValue ) << "Base case was not defined for the scenario";

      m_baseCase.reset( new mbapi::Model() );

      if ( NoError != m_baseCase->loadModelFromProjectFile( m_baseCaseProjectFile.c_str() ) )
      {
         throw ErrorHandler::Exception( ErrorHandler::IoError ) << "defineBaseCase() can not load model from " << m_baseCaseProjectFile;
      }
   }

   return *m_baseCase;
}

void ScenarioAnalysis::ScenarioAnalysisImpl::setScenarioLocation( const char * pathToCaseSet, const bool append )
{
   try
   {
      if ( pathToCaseSet )
      {
         ibs::FolderPath saFolder = ibs::FolderPath( pathToCaseSet );

         if ( !saFolder.exists() )
         {
            saFolder.create();
         }
         else if ( !saFolder.empty() )
         {
            bool found = false;
            for ( int i = 1; i < 99 && !found; ++i )
            {
               ibs::FolderPath tmpPath( saFolder );
               tmpPath << "Iteration_" + ibs::to_string( i );
               if ( !tmpPath.exists() )
               {
                  found = true;
                  m_iterationNum = i;
               }
            }
            if ( !found ) { throw ErrorHandler::Exception( ErrorHandler::IoError ) << "Too many iterations in folder " << pathToCaseSet; }
         }
         // Pick last iteration to write in if it exists
         if ( append && m_iterationNum > 1)
         {
           m_iterationNum--;
         }

         m_caseSetPath = saFolder.fullPath().path();
      }
   }
   catch ( const ibs::PathException & ex ) { throw ErrorHandler::Exception( ErrorHandler::IoError ) << ex.what(); }
}


void ScenarioAnalysis::ScenarioAnalysisImpl::setDoEAlgorithm( DoEGenerator::DoEAlgorithm algo )
{
   m_doe.reset( new DoEGeneratorImpl( algo ) );
}


DoEGenerator * ScenarioAnalysis::ScenarioAnalysisImpl::doeGenerator()
{
   if ( !m_doe.get() ) { setDoEAlgorithm( DoEGenerator::Tornado ); }

   return m_doe.get();
}


void ScenarioAnalysis::ScenarioAnalysisImpl::applyMutations(RunCaseSet & rcs , const bool append)
{
   // construct case set path like pathToScenario/Iteration_XX
   ibs::FolderPath caseSetPath( m_caseSetPath );

   std::string expFld = std::string( "Iteration_" ) + ibs::to_string( m_iterationNum );
   // also use experiment name (if it was set) in folder name pathToScenario/Iteration_XX_ExperimentName
   if ( !rcs.filter().empty() )
   {
     expFld += std::string( "_" ) + rcs.filter();
   }

   caseSetPath << expFld;

   // extract project file name:
   std::string projectFileName = "Project.project3d";
   if ( !m_baseCaseProjectFile.empty() )
   {
      ibs::FilePath pf( m_baseCaseProjectFile );
      const std::string & fn = pf.fileName();
      if ( !fn.empty() )
      {
         projectFileName = fn;
      }
   }

   // generate base case run case and save it as project file
   if ( !m_baseCaseRunCase.get() ) // this wasn't done before
   {
     // create new CASA case
     m_baseCaseRunCase.reset( new RunCaseImpl() );

     // add base parameters value to base case run case
     for ( size_t i = 0; i < m_varSpace->size(); ++i )
     {
       m_baseCaseRunCase->addParameter( m_varSpace->parameter( i )->baseValue() );
     }
   }

   RunCase* baseRunCase = m_baseCaseRunCase.get();
   ibs::FolderPath baseCasePath = caseSetPath;
   baseCasePath << std::string( "BaseCase");
   baseCasePath.create();
   baseCasePath << projectFileName;
   baseRunCase->mutateCaseTo( baseCase(), baseCasePath.path().c_str() );

   for ( size_t i = 0; i < rcs.size(); ++i )
   {
      ibs::FolderPath casePath = caseSetPath;
      casePath << std::string("Case_") + ibs::to_string( m_caseNum );

      RunCase* runCase = rcs[ i ].get();

      const bool createCase = append ? (runCase->runStatus() == RunCase::NotCreated) : true;

      if ( createCase )
      {
         casePath.create();
         casePath << projectFileName;
         runCase->mutateCaseTo( baseCase(), casePath.path().c_str() );
         m_caseNum++;
      }
   }
   ++m_iterationNum;
}


void ScenarioAnalysis::ScenarioAnalysisImpl::extractOneDProjects( const std::string & expLabel )
{
   struct XYCoordComp
   {
      bool operator() ( const casa::ObsGridPropertyWell * c1, const casa::ObsGridPropertyWell * c2 ) const
      {
         // coordinates that differ less than 1 m are equal
         double x1 = c1->xCoords().front(), x2 = c2->xCoords().front();
         if ( std::fabs( x1 - x2 ) > 1 ) { return x1 < x2; }
         double y2 = c2->yCoords().front(), y1 = c1->yCoords().front();
         if ( std::fabs( y1 - y2 ) > 1 )  { return y1 < y2; }
         return false;
      }
   };

   mbapi::Model                                          & mdl = baseCase();
   std::vector<std::shared_ptr<RunCase> >                  expSet;
   std::set<const casa::ObsGridPropertyWell*, XYCoordComp> uniqWellsSet;
   casa::VarSpace                                        & var = varSpace();

   // as a first stem make a unique list of wells based on the first coordinate of the well.
   for ( size_t i = 0; i < m_obsSpace->size(); ++i )
   {
      const casa::ObsGridPropertyWell * wellObs = dynamic_cast<const casa::ObsGridPropertyWell *>( m_obsSpace->observable( i ) );
      if ( wellObs && !wellObs->xCoords().empty() ) { uniqWellsSet.insert( wellObs ); }
   }

   if ( uniqWellsSet.empty() ) { throw ErrorHandler::Exception( ErrorHandler::IoError ) << "No wells extracted, stopping"; }

   // go over all wells and for each extracted wells determine minI, maxI and minJ, maxJ
   for ( auto it = uniqWellsSet.begin(); it != uniqWellsSet.end(); it++ )
   {
      // model coordinates and discretization
      int    minI, maxI, minJ, maxJ;
      double centreX, centreY;

      if ( NoError != mdl.windowSize( (*it)->xCoords().front(), (*it)->yCoords().front(), minI, maxI, minJ, maxJ, centreX, centreY ) )
      {
         throw ErrorHandler::Exception( ErrorHandler::IoError ) << "Setting window around well: " << (*it)->xCoords().front() << " "
                                                                                                  << (*it)->yCoords().front() << " "
                                                                << " for the project failed";
      }

       // the new case to add
      std::shared_ptr<RunCase> newCase( new casa::RunCaseImpl() );

      //  the new window
      SharedParameterPtr window( new casa::PrmWindow( minI, maxI, minJ, maxJ, (*it)->xCoords().front(), (*it)->yCoords().front() ) );
      newCase->addParameter( window );

      // the well coordinates ( for interpolation)
      m_xcoordOneD.push_back( centreX );
      m_ycoordOneD.push_back( centreY );

      // the well coordinates (using i, j positions to extract from the grid)
      std::vector<double> wellCoord;
      wellCoord.push_back( minI );
      wellCoord.push_back( minJ );

      // for other influential parameters, set the values read from the model
      for ( size_t par = 0; par < var.size(); ++par )
      {
         const casa::VarParameter * vprm = var.parameter( par );
         // get the parameter value at the specific x, y location (bottom left corner)
         SharedParameterPtr prm( vprm->newParameterFromModel( mdl, wellCoord ) );
         newCase->addParameter( prm );
      }

      // push back the new case in the experiment set
      expSet.push_back( newCase );
   }

   // add the set of cases in DoE
   m_doeCases->addNewCases( expSet, expLabel );
}

void ScenarioAnalysis::ScenarioAnalysisImpl::importOneDResults( const std::string & expLabel )
{
   RunCaseSet& rcs = doeCaseSet();

   // set the filter for the run case set
   rcs.filterByExperimentName( expLabel );

   // Collect 1D results:
   // get the values of the run cases from casa_state files
   std::vector< std::shared_ptr<RunCase> > bestMatchedCases( rcs.size() );
   std::vector< std::shared_ptr<RunCase> > baseCases(        rcs.size() );
   std::vector< std::shared_ptr<RunCase> > lastRunCases(     rcs.size() );

   for ( size_t c = 0; c < rcs.size(); ++c )
   {
      // load casa_state file from multi1D directories
      ibs::FilePath stateFile( ibs::FilePath( rcs[c]->projectPath() ).filePath() );
      stateFile << "casa_state.bin";

      // load scenario from file (deserialization)
      std::unique_ptr<ScenarioAnalysis> oneDscenario( casa::ScenarioAnalysis::loadScenario( stateFile.cpath(), "bin" ) );

      // get the RunCaseSet
      casa::RunCaseSet & oneDCaseSet = oneDscenario->doeCaseSet();

      // get and add the best matched case
      oneDCaseSet.filterByExperimentName( "BestMatchedCase" );
      if ( oneDCaseSet.size() != 1 )
      {
         throw ErrorHandler::Exception( ErrorHandler::OutOfRangeValue ) << " The best matched case must be present and unique, instead "
            << oneDCaseSet.size() << " cases were found";
      }
      bestMatchedCases[c] = copyAnotherScenarioCase( oneDCaseSet[0] );

      // get the best base case
      oneDCaseSet.filterByExperimentName( "BaseCase" );
      if ( oneDCaseSet.size() != 1 )
      {
         throw ErrorHandler::Exception( ErrorHandler::OutOfRangeValue ) << " The base case must be present and unique, instead "
            << oneDCaseSet.size() << " cases were found";
      }
      baseCases[c] = copyAnotherScenarioCase( oneDCaseSet[0] );

      // get the last run case
      oneDCaseSet.filterByExperimentName( "LMSteps" );
      if ( oneDCaseSet.size() < 1 )
      {
         throw ErrorHandler::Exception( ErrorHandler::OutOfRangeValue ) << " Cannot extract the last run case because the LMSteps case set size is "
            << oneDCaseSet.size();
      }
      lastRunCases[c] = copyAnotherScenarioCase( oneDCaseSet[oneDCaseSet.size() - 1] );
   }

   if ( m_xcoordOneD.size() != bestMatchedCases.size() )
   {
      throw ErrorHandler::Exception( ErrorHandler::UnknownError ) << " The number of extracted wells is not equal to the number"
         << " of the calibrated 1D cases";
   }

   // set the filter back and add the cases
   rcs.filterByExperimentName( "" );
   rcs.addNewCases( bestMatchedCases, "BestMatchedOneDCases" );
   rcs.addNewCases( baseCases, "BaseOneDCases" );
   rcs.addNewCases( lastRunCases, "LastRunOneDCases" );
}

void ScenarioAnalysis::ScenarioAnalysisImpl::setFilterOneDResults( const std::string & filterAlgorithm )
{
   // Just set the filtering algorithm
   if ( filterAlgorithm == "smartLithoFractionGridding")
   {
      m_filteringAlgorithm = 1;
   }
   // for other cases add an else if
   else
   {
      throw ErrorHandler::Exception( ErrorHandler::NotImplementedAPI ) << "The filter algorithm " << filterAlgorithm << " is not implemented";
   }
}

bool ScenarioAnalysis::ScenarioAnalysisImpl::parameterFilter( Parameter * prm, RunCase * rc )
{
   mbapi::Model  *  model = rc->caseModel( );
   bool includeParameter = false;

   if ( m_filteringAlgorithm == 1 )
   {
      // Only the lithofraction parameters should be filtered in smartLithoFractionGridding
      const casa::PrmLithoFraction * lf = dynamic_cast<PrmLithoFraction *>( prm );
      if ( !lf ) return true;
      std::string layerName = lf->layerName( );
      int numObs = 0;
      size_t numObservables = rc->observablesNumber( );
      for ( size_t ob = 0; ob < numObservables; ++ob )
      {
         const Observable * obsv = rc->obsValue( ob )->parent( );
         const casa::ObsGridPropertyWell * wellObs = dynamic_cast<const casa::ObsGridPropertyWell *>( obsv );
         if ( wellObs )
         {
            std::vector<double> xc = wellObs->xCoords( );
            std::vector<double> yc = wellObs->yCoords( );
            std::vector<double> zc = wellObs->depth( );
            for ( size_t i = 0; i < zc.size( ); ++i )
            {
               if ( model->checkPoint( xc[i], yc[i], zc[i], layerName ) ) numObs += 1;
            }
         }
      }
      // include the parameter if we have at least 1 well observation for the lithofraction parameter
      includeParameter = numObs >= 1;
   }
   // for other cases add an else if
   else
   {
      // by default we should not apply any filtering
      return true;
   }

   return includeParameter;
}

void ScenarioAnalysis::ScenarioAnalysisImpl::generateThreeDFromOneD( const std::string & expLabel, const int smoothingMethod,
                                                                     const double smoothingRadius, const int nrOfThreads )
{
   RunCaseSet& rcs = doeCaseSet( );
   VarSpace& var = varSpace( );
   mbapi::Model& bc = baseCase( );
   const std::string            threeDFromOneD( "ThreeDFromOneD" );

   // get the OneDProjects
   std::vector<std::shared_ptr<RunCase>> baseOneDCases;
   rcs.filterByExperimentName( "OneDProjects" );
   baseOneDCases.resize( rcs.size( ) );
   for ( size_t c = 0; c < rcs.size( ); ++c )
   {
      baseOneDCases[c] = rcs[c];
   }
   rcs.filterByExperimentName( "" );

   // set the filter for the bestMatchedCases
   rcs.filterByExperimentName( expLabel );
   if ( baseOneDCases.size( ) != rcs.size( ) )
   {
      throw ErrorHandler::Exception( ErrorHandler::UnknownError ) << " The number of base 1D cases is not equal to the number the best 1D cases";
   }

   // Create 3D case with best parameters
   // the best run case
   std::shared_ptr<RunCase> brc( new casa::RunCaseImpl( ) );

   // Vectors storing the filtered parameters of each 1D case and their x and y coordinates
   std::vector<SharedParameterPtr> prmVec;
   std::vector<double> xcoordOneD;
   std::vector<double> ycoordOneD;

   // loop over all IPs
   for ( size_t par = 0; par < var.size(); ++par )
   {
      const casa::VarParameter * vprm = var.parameter( par );
      switch ( vprm->variationType() )
      {
         case casa::VarParameter::Continuous:
         {
            const casa::VarPrmContinuous * vprmc = dynamic_cast<const casa::VarPrmContinuous*>( vprm );

            for ( size_t c = 0; c < rcs.size(); ++c )
            {
               SharedParameterPtr nprm = rcs[c]->parameter( par );
               // add only valid parameters
               if ( parameterFilter( nprm.get(), baseOneDCases[c].get() ) )
               {
                  prmVec.push_back( nprm );
                  xcoordOneD.push_back( m_xcoordOneD[c]);
                  ycoordOneD.push_back( m_ycoordOneD[c]);
               }
            }

            try
            {
               // if the average method is not implemented a makeThreeDFromOneD will throw exception
               if ( prmVec.size() > 0 )
               {
                  // make the averages
                  SharedParameterPtr prm;
                  VarPrmContinuous::SmoothingParams smoothingParams{ smoothingMethod, smoothingRadius, nrOfThreads };
                  prm = vprmc->makeThreeDFromOneD( bc, xcoordOneD, ycoordOneD, prmVec, smoothingParams );
                  brc->addParameter( prm );
               }
            }
            catch ( const ErrorHandler::Exception & ex )
            {
                  throw ErrorHandler::Exception( ex.errorCode() ) << " The generation of the 3D parameter " << vprmc->name()
                                                                  << " from multi 1D results failed. Error message: " << ex.what();
            }

            //clear previous arrays stored for the mean values
            prmVec.clear();
            xcoordOneD.clear();
            ycoordOneD.clear();
         }
         break;

         case casa::VarParameter::Categorical: brc->addParameter( vprm->baseValue() ); break;
         case casa::VarParameter::Discrete:
         default:
            throw ErrorHandler::Exception( ErrorHandler::NotImplementedAPI ) << "Not implemented influential parameter type: " << vprm->variationType();
            break;
      }
   }

   // construct case project path for the best case
   ibs::FolderPath casePath( "." );
   casePath << threeDFromOneD;

   if ( casePath.exists() ) // clean folder if it is already exist
   {
      casePath.remove();
   }

   casePath.create();
   casePath << ( std::string( baseCaseProjectFileName() ).empty() ? "Project.project3d" : baseCaseProjectFileName() );

   // do mutation
   brc->mutateCaseTo( bc, casePath.fullPath().cpath() );

   // validate the case
   std::string msg = brc->validateCase();
   if ( !msg.empty() )
   {
      throw ErrorHandler::Exception( ErrorHandler::ValidationError ) << " An invalid project was generated " << casePath.path();
   }

   // Add the cases to the run case set
   std::vector<std::shared_ptr<RunCase>> bestMatchedCase;
   bestMatchedCase.push_back( brc );
   rcs.addNewCases( bestMatchedCase, threeDFromOneD );
}

void ScenarioAnalysis::ScenarioAnalysisImpl::validateCaseSet( RunCaseSet & rcs )
{
   // exception object which will keep list of validation error
   ErrorHandler::Exception ex( ErrorHandler::ValidationError );
   bool allValid = true;

   for ( size_t i = 0; i < rcs.size(); ++i )
   {
      RunCase * cs = rcs[ i ].get();

      if ( cs )
      {
         const std::string errList = cs->validateCase();
         if ( !errList.empty() )
         {
            ex << "Case: " << i + 1 << " validation failed with message: " << errList;
            allValid = false;
         }
      }
   }

   if ( !allValid ) throw ex;
}


void ScenarioAnalysis::ScenarioAnalysisImpl::calibrateProjectUsingOptimizationAlgorithm( const std::string & cbProjectName
                                                                                       , const std::string & optimAlg
                                                                                       , ScenarioAnalysis  & sa
                                                                                       , bool                // keepHistory
                                                                                       , const std::string & transformation
                                                                                       , const double        relativeReduction
                                                                                       )
{
   std::unique_ptr<OptimizationAlgorithm> optAlgo;

   if ( optimAlg == "LM" ) { optAlgo.reset( new LMOptAlgorithm( cbProjectName, transformation, relativeReduction ) ); }
   else { throw Exception( OutOfRangeValue ) << "Unsupported optimization algorithm name: " << optimAlg; }

   optAlgo->runOptimization( sa );
}

void ScenarioAnalysis::ScenarioAnalysisImpl::saveCalibratedCase( const char * projFileName, size_t mcSampleNum )
{
   if ( mcSampleNum < 1 )
   {
      throw Exception( MonteCarloSolverError ) << "Monte Carlo sampling numbering starts with 1, can not get sample point:" << mcSampleNum;
   }
   if ( m_mcSolver->samplingsNumber() < mcSampleNum )
   {
      throw Exception( MonteCarloSolverError ) << "Requested Monte Carlo sampling point number bigger than total number of sampling points";
   }

   RunCase * bmCase = const_cast<RunCase*>( m_mcSolver->samplingPoint( mcSampleNum-1 ) ); // by default samples are sorted according to RMSE
   if ( !bmCase )
   {
      throw Exception( MonteCarloSolverError ) << "Can not generate calibrated case: " << projFileName <<
                                                  ". Monte Carlo simulation should be done first";
   }

   // construct best matched case set path like pathToScenario/BestMatch_projFileName
   ibs::FilePath fp( projFileName );

   ibs::FolderPath bmCasePath( m_caseSetPath );
   bmCasePath << std::string( "Calibrated_" ) + fp.fileNameNoExtension();

   if ( bmCasePath.exists() ) throw ErrorHandler::Exception( ErrorHandler::IoError ) << " folder " << bmCasePath.path() << " is not empty";

   bmCasePath.create();
   bmCasePath << projFileName;

   // do mutation
   bmCase->setCleanDuplicatedLithologies( true );
   bmCase->mutateCaseTo( baseCase(), bmCasePath.path().c_str() );
   // add observables
   m_dataDigger->requestObservables( *m_obsSpace, bmCase );
   // generate scripts
   m_runManager->scheduleCase( *bmCase, scenarioID() );
}

void ScenarioAnalysis::ScenarioAnalysisImpl::addRSAlgorithm( const std::string              & name
                                                           , const int                        order
                                                           , RSProxy::RSKrigingType           krType
                                                           , const std::vector<std::string> & doeList
                                                           )
{
   if ( name.empty() ) throw Exception( OutOfRangeValue ) << "addRSAlgorithm(): empty proxy name";

   if ( m_rsProxySet->hasProxyName( name ) ) // already has response surface with the same name
   {
      throw Exception( AlreadyDefined ) << "addRSAlgorithm(): proxy with name: " << name << ", already exists in the scenario";
   }
   else
   {
     RSProxy * proxy = createRSProxy( name, order, krType );
     // if DoEs name list is not empty - calculate response surface
     if ( doeList.size() )
     {
       const std::vector<const casa::RunCase *> & runCases = m_doeCases->collectCompletedCases( doeList );
       calculateRSProxy( proxy, runCases );
     }

     m_rsProxySet->addNewRSProxy( proxy, name );
   }
}

RSProxy * ScenarioAnalysis::ScenarioAnalysisImpl::createRSProxy( const std::string      & name
                                                               , const int                order
                                                               , RSProxy::RSKrigingType   krType
                                                               )
{
   if ( order < -1 || order > 3 )
   {
      throw Exception( OutOfRangeValue ) << "createRSProxy(): initiateRSProxyConstruction(): wrong value for the order: " << order <<
                                            ", must be in range: [0:3]";
   }

   if ( !obsSpace().size() )
   {
     throw Exception( RSProxyError ) << "createRSProxy(): No observable is defined for proxy calculation";
   }

   if ( !varSpace().size() )
   {
     throw Exception( RSProxyError ) << "createRSProxy(): No influential parameter is defined for proxy calculation";
   }

   RSProxy * proxy;

   switch ( order )
   {
     case -1: proxy = new RSProxyImpl( name, varSpace(), obsSpace(), 0,     krType, true ); break;
     case  0:
     case  1:
     case  2: proxy = new RSProxyImpl( name, varSpace(), obsSpace(), order, krType                 ); break;
     case  3: proxy = new RSProxyImpl( name, varSpace(), obsSpace(), 0,     krType, true, 1.0      ); break;
   }

   return proxy;
}

void ScenarioAnalysis::ScenarioAnalysisImpl::calculateRSProxy( RSProxy                                  * proxy
                                                             , const std::vector<const casa::RunCase *> & runCases
                                                             ) const
{
  if ( proxy == nullptr )
  {
    throw Exception( UndefinedValue ) << "calculateRSProxy(): provided proxy is not initiated for construction!";
  }

  if ( runCases.empty() ) throw Exception( RSProxyError ) << "calculateRSProxy(): empty completed cases list for given DoEs";

  if ( NoError != proxy->calculateRSProxy( runCases ) )
  {
    throw Exception( proxy->errorCode() ) << proxy->errorMessage();
  }
}

void ScenarioAnalysis::ScenarioAnalysisImpl::serialize( CasaSerializer & outStream )
{
   bool ok = outStream.save( m_caseSetPath,         "caseSetPath"           );
   ok = ok ? outStream.save( m_baseCaseProjectFile, "baseCaseProjectFile"   ) : ok;
   ok = ok ? outStream.save( m_iterationNum,        "iterationNum"          ) : ok;
   ok = ok ? outStream.save( m_caseNum,             "caseNum"               ) : ok;

   ok = ok ? outStream.save( m_xcoordOneD,          "xCoord1D"              ) : ok; // version 10
   ok = ok ? outStream.save( m_ycoordOneD,          "yCoord1D"              ) : ok; // version 10
   ok = ok ? outStream.save( m_filteringAlgorithm,  "filteringAlgorithm"    ) : ok; // version 11

   ok = ok ? outStream.save( obsSpace(),            "ObsSpace"              ) : ok; // serialize observables manager
   ok = ok ? outStream.save( varSpace(),            "VarSpace"              ) : ok; // serialize influential parameters set

   ok = ok ? outStream.save( *m_doeCases.get(),     "DoECasesSet"           ) : ok;
   ok = ok ? outStream.save( *m_mcCases.get(),      "MCCasesSet"            ) : ok;
   ok = ok ? outStream.save( *m_rsProxySet.get(),   "RSProxySet"            ) : ok;

   ok = ok ? outStream.save( *(doeGenerator()),     "DoE"                   ) : ok; // serialize doe generator
   ok = ok ? outStream.save( dataDigger(),          "DataDigger"            ) : ok; // data digger
   ok = ok ? outStream.save( runManager(),          "RunManager"            ) : ok; // run manager

   ok = ok ? outStream.save( mcSolver(),            "MCSolver"              ) : ok;
   ok = ok ? outStream.save( *m_sensCalc.get(),     "SensitivityCalculator" ) : ok;
   ok = ok ? outStream.save( m_scenarioID,          "scenarioID"            ) : ok;

   if ( !ok ) throw ErrorHandler::Exception( SerializationError ) << "Serialization error in ScenarioAnalysis";
}

// Load ScenarioAnalysis object from file
void ScenarioAnalysis::ScenarioAnalysisImpl::deserialize( CasaDeserializer & inStream )
{
   if ( inStream.version() < 9 )
   {
      throw Exception( DeserializationError ) << "Incompatible casa state file version. Versions 9 and later are incompatible with " <<
         " the given state file version: " <<  inStream.version();
   }

   bool ok = inStream.load( m_caseSetPath,         "caseSetPath" );

   // read base case name and load it as a model
   std::string baseCaseName;
   ok = ok ? inStream.load( baseCaseName, "baseCaseProjectFile" ) : ok;

   if ( ok ) defineBaseCase( baseCaseName.c_str() );

   ok = ok ? inStream.load( m_iterationNum,        "iterationNum" ) : ok;
   ok = ok ? inStream.load( m_caseNum,             "caseNum"      ) : ok;

   if ( inStream.version() > 9 )
   {
      ok = ok ? inStream.load( m_xcoordOneD,               "xCoord1D"           ) : ok; // version 10
      ok = ok ? inStream.load( m_ycoordOneD,               "yCoord1D"           ) : ok; // version 10
      ok = ok ? inStream.load( m_filteringAlgorithm,       "filteringAlgorithm" ) : ok; // version 11
   }

   if ( !ok ) throw Exception( DeserializationError ) << "Deserialization error in ScenarioAnalysis";

   m_obsSpace.reset(   new ObsSpaceImpl(              inStream, "ObsSpace"              ) );
   m_varSpace.reset(   new VarSpaceImpl(              inStream, "VarSpace"              ) );

   m_doeCases.reset(   new RunCaseSetImpl(            inStream, "DoECasesSet"           ) );
   m_mcCases.reset(    new RunCaseSetImpl(            inStream, "MCCasesSet"            ) );
   m_rsProxySet.reset( new RSProxySetImpl(            inStream, "RSProxySet"            ) );

   m_doe.reset(        new DoEGeneratorImpl(          inStream, "DoE"                   ) );
   m_dataDigger.reset( new DataDiggerImpl(            inStream, "DataDigger"            ) );
   m_runManager.reset( new RunManagerImpl(            inStream, "RunManager"            ) );
   m_mcSolver.reset(   new MonteCarloSolverImpl(      inStream, "MCSolver"              ) );
   m_sensCalc.reset(  new SensitivityCalculatorImpl(  inStream, "SensitivityCalculator" ) );

   inStream.load( m_scenarioID, "scenarioID" );
}

// Make a deep copy of the run case between 2 scenarios
std::shared_ptr<RunCaseImpl> ScenarioAnalysis::ScenarioAnalysisImpl::copyAnotherScenarioCase( const std::shared_ptr<RunCase> cs )
{
   std::shared_ptr<RunCaseImpl> ncs( new RunCaseImpl() );

   // check that parameters space has the same dimension
   if ( cs->parametersNumber() != varSpace().size() )
   {
      throw ErrorHandler::Exception( ErrorHandler::OutOfRangeValue ) << "Import run case: IP space for the current scenario is different " <<
                                                                         varSpace().size() << " != " << cs->parametersNumber();
   }

   // import paramters using SUMlib <-> CASA converters
   SUMlib::Case slcs;

   sumext::convertCase( *cs, varSpace(), slcs  ); // casa -> sumlib
   sumext::convertCase( slcs, varSpace(), *ncs ); // sumlib -> casa

   if ( cs->observablesNumber() != obsSpace().size() )
   {
      throw ErrorHandler::Exception( ErrorHandler::OutOfRangeValue ) << "Import run case: targets number for the current scenario is different " <<
                                                                         obsSpace().size() << " != " << cs->observablesNumber();
   }

   // import observables
   // go over all observable
   for ( size_t j = 0; j < cs->observablesNumber(); ++j )
   {
      // get observable value and check is it double?
      const ObsValue * obv = cs->obsValue( j );

      if ( !obv || !obv->parent() || obv->parent()->typeName() != m_obsSpace->observable( j )->typeName() )
      {
         throw ErrorHandler::Exception( ErrorHandler::OutOfRangeValue ) << "Can not convert target " << m_obsSpace->observable( j )->name()[0];
      }

      if ( obv->isDouble() )
      {
         // push values of observable to array of targets
         const std::vector<double> & vals = obv->asDoubleArray( false );
         std::vector<double>::const_iterator it = vals.begin();
         const ObsValue * nobv = m_obsSpace->observable( j )->createNewObsValueFromDouble( it );
         ncs->addObsValue( nobv );
      }
      else
      {
         throw ErrorHandler::Exception( ErrorHandler::NotImplementedAPI ) << "Non double targets are not implemented yet";
      }
   }
   return ncs;
}

}
