#include "resultstabulator.h"
#include "variabledefinitions.h"
#include "parameterdefinitions.h"
#include "parametersettings.h"
#include "formattingexception.h"

#include <fstream>
#include <iomanip>

namespace hpc
{
   
std::ostream & 
writeResultsTabulatorScript( std::ostream & output, const ParameterDefinitions & parameters, const VariableDefinitions & variables, const std::vector< ParameterSettings > & settings, const std::string & canonicalDirWithResults)
{
   const int fieldWidth = 20;

   output 
      << "#!/bin/bash\n"
      << "### DO NOT EDIT THIS FILE. This file has been automatically generated\n"
      << "\n";
   // write variable descriptions
   output
      << "echo Clarification of variable names\n";
   for ( unsigned i = 0; i < variables.definitions().size(); ++i )
   {
      output
         << "echo ' . " << variables.definitions()[i].name 
                       << ": " << variables.definitions()[i].description << "'\n";
   }
   output 
      << "echo\n";

   // memorize the parameters in the table header
   // parameters
   std::vector< std::string > paramNames;
   paramNames.push_back("ID");
   //paramNames.push_back("Project"); commented out, because this field is very wide and messes up the alignment in the table
   paramNames.push_back("Processors");
   paramNames.push_back("CauldronVersion") ;

   typedef ParameterDefinitions::ProjectParamMap::const_iterator PDPPIt;
   for (PDPPIt i = parameters.projectParameters().begin(); i != parameters.projectParameters().end(); ++i)
      paramNames.push_back( i->first );

   typedef ParameterDefinitions::CmdLineParamMap::const_iterator PDCLPIt;
   for (PDCLPIt i = parameters.cauldronCmdLineParameters().begin(); i != parameters.cauldronCmdLineParameters().end(); ++i)
      paramNames.push_back( i->first );

   for (PDCLPIt i = parameters.mpiCmdLineParameters().begin(); i != parameters.mpiCmdLineParameters().end(); ++i)
      paramNames.push_back( i->first);

   // write the table header
   output
      << "echo '";

   for (unsigned i = 0; i < paramNames.size(); ++i)
     output << std::setw(fieldWidth) << paramNames[i] << ' ';
   
   for ( unsigned i = 0; i < variables.definitions().size(); ++i )
      output << std::setw(fieldWidth) << variables.definitions()[i].name << ' ';

   output
       << "'\n";

    // write a record with an extraction script for each parameter setting
   for (unsigned s = 0 ; s < settings.size(); ++ s)
   {
      typedef ParameterSettings::Map::const_iterator PSMIt;
      PSMIt id = settings[s].map().find("ID");
      if (id == settings[s].map().end())
         throw formattingexception::GeneralException() << "Parameter setting does not have 'ID' field";
       
      output << "\n# Computing variables for setting '" << id->second << "'\n";
      // set FILE variable
      output << "FILE='" << canonicalDirWithResults << "/" << id->second << "/output'\n";

      // compute value of variables
      for ( unsigned i = 0; i < variables.definitions().size(); ++i )
      {
         const std::string & variableName = variables.definitions()[i].name;
         const std::string & script = variables.definitions()[i].script;

         output << variableName << "=" << script << '\n';
      }

      // output parameter settings
      output
         << "echo -n '";
      for (unsigned i = 0; i < paramNames.size(); ++i)
      {
         PSMIt param = settings[s].map().find( paramNames[i] );
         if (param == settings[s].map().end())
            output << std::setw(fieldWidth) << " " << " ";
         else
            output << std::setw(fieldWidth) << param->second << " ";
      }
      output
         << "'\n";

      // output variables
      output << "printf '";
      for (unsigned i = 0; i < variables.definitions().size(); ++i)
         output << "% " << fieldWidth << "s ";
      output << "\\n' ";

      for (unsigned i = 0; i < variables.definitions().size(); ++i)
         output << "${" << variables.definitions()[i].name << "} ";
      output << '\n';
   }

   return output;
}

}
