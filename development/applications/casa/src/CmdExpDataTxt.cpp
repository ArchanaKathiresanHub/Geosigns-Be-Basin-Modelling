//                                                                      
// Copyright (C) 2012-2017 Shell International Exploration & Production.
// All rights reserved.
// 
// Developed under license for Shell by PDS BV.
// 
// Confidential and proprietary source code of Shell.
// Do not distribute without written permission from Shell.
// 

#include "CasaCommander.h"
#include "CmdExpDataTxt.h"
#include "CmdEvaluateResponse.h"

#include "casaAPI.h"
#include "RunCase.h"

#include "LogHandler.h"

#include <cstdlib>
#include <iostream>
#include <fstream>
#include <iomanip>

using namespace casa;

//////////////////////////////////////////////////////////////////////////////////////////
// Auxiliary functions
//
static void ExtractObservableValues( std::vector<double> & result, const RunCase * cs )
{
   // go over all observables and calculate PrxVal for each observable
   for ( size_t j = 0; j < cs->observablesNumber(); ++j )
   {
      const casa::ObsValue * obv = cs->obsValue( j );

      if ( !obv->isDouble() ) continue;

      const std::vector<double> & vals = obv->asDoubleArray();
      result.insert( result.end(), vals.begin(), vals.end() );
   }
}

static void ExtractParametersValues( std::vector<double> & result, const RunCase * cs )
{
   for ( size_t j = 0; j < cs->parametersNumber(); ++j )
   {
      const casa::Parameter * prm = cs->parameter( j ).get();

      if ( !prm || !prm->parent() ) continue;

      switch ( prm->parent()->variationType() )
      {
         case casa::VarParameter::Continuous:
         case casa::VarParameter::Discrete:
            {
               const std::vector<double> & vals = prm->asDoubleArray();
               result.insert( result.end(), vals.begin(), vals.end() );
            }
            break;

         case casa::VarParameter::Categorical:
            result.push_back( prm->asInteger() );
            break;
         
         default: assert( false ); break;
      }
   }
}
/////////////////////////////////////////////////////////////////////////////////////////

CmdExpDataTxt::CmdExpDataTxt( CasaCommander & parent, const std::vector< std::string > & cmdPrms ) : CasaCmd( parent, cmdPrms )
{
   if ( m_prms.size() < 2 )
   {
      throw ErrorHandler::Exception( ErrorHandler::RSProxyError ) << "Wrong parameters number: " 
         << m_prms.size() << " (expected 2 or more) in data export command";
   }

   m_whatToSave   = m_prms[0];
   m_dataFileName = m_prms[1].empty() ? (m_whatToSave + ".dat") : m_prms[1];

   if ( m_whatToSave == "DoEParameters" )
   {
      // convert list of DoEs or data files like: "Tornado,BoxBenken" into array of names
      if ( m_prms.size() > 2 ) { m_expList = CfgFileParser::list2array( m_prms[2], ',' ); }
   }
   else if ( m_whatToSave == "RunCasesObservables" )
   {
      if ( m_prms.size() > 2 ) { m_expList = CfgFileParser::list2array( m_prms[1], ',' ); }
   }
   else if ( m_whatToSave == "ProxyEvalObservables" || m_whatToSave == "ProxyQC" )
   {
      if ( m_prms.size() > 2 ) { m_expList = CfgFileParser::list2array( m_prms[2], ',' ); }
      if ( m_prms.size() > 3 ) { m_proxyName = m_prms[3]; }

      if ( m_proxyName.empty() ) throw ErrorHandler::Exception( ErrorHandler::UndefinedValue ) << "No proxy name was given";
   }
   else if ( m_whatToSave == "MCResults" )
   {
      // no parameters to be parsed 
      ;
   }
   else { throw ErrorHandler::Exception( ErrorHandler::RSProxyError ) << "Unknown command parameter: " <<  m_whatToSave; }
}

void CmdExpDataTxt::execute( std::unique_ptr<casa::ScenarioAnalysis> & sa )
{
   LogHandler( LogHandler::INFO_SEVERITY ) << "Exporting CASA results for " << m_whatToSave << " to : " << m_dataFileName << "...";

   if (      m_whatToSave == "DoEParameters"        ) { exportParameters( sa ); }
   else if ( m_whatToSave == "RunCasesObservables"  ) { exportRunCaseObs( sa ); } 
   else if ( m_whatToSave == "ProxyEvalObservables" ) { exportEvalObserv( sa ); }
   else if ( m_whatToSave == "ProxyQC"              ) { exportProxyQC(    sa ); }
   else if ( m_whatToSave == "MCResults"            ) { exportMCResults(  sa ); }

   LogHandler( LogHandler::INFO_SEVERITY ) << "Exporting CASA results succeeded.";
}

void CmdExpDataTxt::printHelpPage( const char * cmdName )
{
   std::cout << "  " << cmdName << R"( <what> <fileName> [<DoEList>] [<proxyName>]

     Export in plane txt file scenario data. This command goes over all run cases from the list of specified DoEs
     (if list wasn't specified - over all DoEs in scenario) and export numerical data for:
          DoEParameters       : generated by DoE parameters value
          RunCasesObservables : extracted from simulations observables value
          ProxyEvalObservables: evaluated from the given response surface observables value
          ProxyQC:              relation of simulated to evaluated observables value
          MCResults:            variable parameters and observables value from MC/MCMC simulation

     Where:
          what     - DoEParameters/RunCasesObservables/ProxyEvalObservables/ProxyQC
          fileName - file name to export data
          DoEList  - (Optional) comma separated list of DoEs name
          proxyName - must be defined for ProxyEvalObservables/ProxyQC. Proxy name which will be used to calculate observables value
   
       Example:
       )" << cmdName << R"( "ProxyQC" "datafile.txt"  "FullFactorial,Tornado" "FirstOrderProxy"\n)";
}

void CmdExpDataTxt::saveResults( const std::vector< std::vector<double> > & res )
{
   std::ofstream ofs;

   ofs.open( m_dataFileName.c_str(), std::ios_base::out | std::ios_base::trunc );

   if ( ofs.fail() ) throw ErrorHandler::Exception( ErrorHandler::IoError ) << "Can not open file for writing: " << m_dataFileName;

   for ( size_t i = 0; i < res.size(); ++i )
   {
      for ( size_t j = 0; j < res[i].size(); ++j )
      {
         ofs << std::scientific << std::setprecision( 8 )  << std::setfill( '0' ) << res[i][j] << " ";
      }
      ofs << std::endl;
   }
   ofs.close();
}


void CmdExpDataTxt::exportParameters( std::unique_ptr<casa::ScenarioAnalysis> & sa )
{
   LogHandler( LogHandler::INFO_SEVERITY ) << "Exporting parameters value calculated by DoEs to " << m_dataFileName << "...";

   casa::RunCaseSet & doeCaseSet = sa->doeCaseSet();
   std::vector<std::string> doeList = m_expList.empty() ? doeCaseSet.experimentNames() : m_expList;

   std::vector< std::vector<double> > results;

   for ( size_t e = 0; e < doeList.size(); ++e )
   {
      doeCaseSet.filterByExperimentName( doeList[e] );

      for ( size_t c = 0; c < doeCaseSet.size(); ++c )
      {
         results.push_back( std::vector<double>() );

         // go over all parameters 
         ExtractParametersValues( results.back(), doeCaseSet.runCase( c ) ); 
      }
   }
   saveResults( results );
}

void CmdExpDataTxt::exportRunCaseObs( std::unique_ptr<casa::ScenarioAnalysis> & sa )
{
   LogHandler( LogHandler::INFO_SEVERITY ) << "Export observables value calculated in DoEs runs to " << m_dataFileName << "...";

   casa::RunCaseSet & doeCaseSet = sa->doeCaseSet();
   std::vector<std::string> doeList = m_expList.empty() ? doeCaseSet.experimentNames() : m_expList;

   std::vector< std::vector<double> > results;

   for ( size_t e = 0; e < doeList.size(); ++e )
   {
      doeCaseSet.filterByExperimentName( doeList[e] );

      for ( size_t c = 0; c < doeCaseSet.size(); ++c )
      {
         results.push_back( std::vector<double>() );

         // go over all observables and extract values 
         ExtractObservableValues( results.back(), doeCaseSet.runCase( c ) );
      }
   }
   saveResults( results );
}

void CmdExpDataTxt::exportEvalObserv( std::unique_ptr<casa::ScenarioAnalysis> & sa )
{
   LogHandler( LogHandler::INFO_SEVERITY ) << "Exporting observables value for response surface proxy " << m_proxyName << " to " << m_dataFileName << "...";

   std::vector<std::string> doeList = m_expList.empty() ? sa->doeCaseSet().experimentNames() : m_expList;

   std::vector<casa::RunCase *> rcs; // set of run cases which were created from set of parameters defined in external dat file
   std::vector<size_t> casePerExp;
  
   CmdEvaluateResponse::createRunCasesSet( sa, rcs, doeList, casePerExp ); // create new set of run cases with parameters value

   // Search for given proxy name in the set of calculated proxies
   casa::RSProxy * proxy = sa->rsProxySet().rsProxy( m_proxyName.c_str() );
   // call response evaluation
   if ( !proxy ) { throw ErrorHandler::Exception( ErrorHandler::NonexistingID ) << "Unknown proxy name:" << m_proxyName; }

   std::vector< std::vector<double> > results( rcs.size() );

   size_t i = 0;
   for ( size_t e = 0; e < doeList.size(); ++e )
   {
      LogHandler( LogHandler::DEBUG_SEVERITY ) << "Evaluating proxy for " << doeList[e]  << "DoE for " << casePerExp[e]  << " cases...";
      
      for ( size_t c = 0; c < casePerExp[e]; ++c )
      {
         assert( i < rcs.size() );

         if ( ErrorHandler::NoError != proxy->evaluateRSProxy( *rcs[i] ) )
         {
            throw ErrorHandler::Exception( proxy->errorCode() ) << proxy->errorMessage();
         }

         // go over all observables and calculate PrxVal for each observable
         ExtractObservableValues( results[i], rcs[i] );
         ++i;
      }
   }
   saveResults( results );

}

void CmdExpDataTxt::exportProxyQC( std::unique_ptr<casa::ScenarioAnalysis> & sa )
{
   LogHandler( LogHandler::INFO_SEVERITY ) << "Exporting QC data for response surface proxy " << m_proxyName << " to " << m_dataFileName << "...";

   casa::RunCaseSet & doeCaseSet = sa->doeCaseSet();
   std::vector<std::string> doeList = m_expList.empty() ? doeCaseSet.experimentNames() : m_expList;

   std::vector<casa::RunCase *> rcs; // set of run cases which were created from set of parameters defined in external dat file
   std::vector<size_t> casePerExp;
  
   CmdEvaluateResponse::createRunCasesSet( sa, rcs, doeList, casePerExp ); // create new set of run cases with parameters value

   // Search for given proxy name in the set of calculated proxies
   casa::RSProxy * proxy = sa->rsProxySet().rsProxy( m_proxyName.c_str() );
   // call response evaluation
   if ( !proxy ) { throw ErrorHandler::Exception( ErrorHandler::NonexistingID ) << "Unknown proxy name:" << m_proxyName; }

   std::vector< std::vector<double> > results( rcs.size() );

   size_t i = 0;
   for ( size_t e = 0; e < doeList.size(); ++e )
   {
      LogHandler( LogHandler::DEBUG_SEVERITY ) << " evaluating proxy for " << doeList[e]  << " DoE for " << casePerExp[e]  << " cases...";
      
      doeCaseSet.filterByExperimentName( doeList[e] );

      for ( size_t c = 0; c < casePerExp[e]; ++c )
      {
         assert( i < rcs.size() );

         if ( ErrorHandler::NoError != proxy->evaluateRSProxy( *rcs[i] ) )
         {
            throw ErrorHandler::Exception( proxy->errorCode() ) << proxy->errorMessage();
         }

         // go over all observables and calculate PrxVal/SimVal for each observable
         for ( size_t j = 0; j < rcs[i]->observablesNumber(); ++j )
         {
            const casa::ObsValue * obsPrx = rcs[i]->obsValue( j );
            const casa::ObsValue * obsSim = doeCaseSet[c]->obsValue( j );

            if ( !obsPrx->isDouble() || !obsSim->isDouble() ) continue;

            const std::vector<double> & valsPrx = obsPrx->asDoubleArray();
            const std::vector<double> & valsSim = obsSim->asDoubleArray();

            assert( valsSim.size() == valsPrx.size() );

            for ( size_t k = 0; k < valsPrx.size(); ++k )
            {
               double rel = std::abs( valsSim[k] ) < 1e-20 ? ( std::abs( valsPrx[k] ) < 1e-20 ? 1.0 : Utilities::Numerical::IbsNoDataValue ) :
                                                             ( valsPrx[k] / valsSim[k] );
               results[i].push_back( rel );
            }
         }
         ++i;
      }
   }
   saveResults( results );
}
         
void CmdExpDataTxt::exportMCResults( std::unique_ptr<casa::ScenarioAnalysis> & sa )
{
   LogHandler( LogHandler::INFO_SEVERITY ) << "Exporting MC/MCMC to " << m_dataFileName << "...";

   std::vector< std::vector<double> > results;
   // export MC samples
   const MonteCarloSolver::MCResults & mcSamples = sa->mcSolver().getSimulationResults();

   for ( size_t i = 0; i < mcSamples.size(); ++i )
   {
      results.push_back( std::vector<double>() );
      
      std::vector<double> & rsmpl = results.back();
      rsmpl.push_back( static_cast<double>( i ) );                //sample num
      rsmpl.push_back(mcSamples[i].first); //sample RMSE

      // sample parameters set
      ExtractParametersValues( rsmpl, mcSamples[i].second );
      // extract observables values set
      ExtractObservableValues( rsmpl, mcSamples[i].second );
   }
   saveResults( results );
}
