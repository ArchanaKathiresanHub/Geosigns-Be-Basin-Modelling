// Copyright 2014, Shell Global Solutions International B.V.
// All rights reserved. This document and the data and information contained herein is CONFIDENTIAL.
// Neither the whole nor any part of this document may be copied, modified or distributed in any
// form without the prior written consent of the copyright owner.

#include "Exception.h"
#include "NumericUtils.h"
#include "ParameterComponentTransforms.h"

#include <cassert>
#include <cmath>
#include <string>

namespace SUMlib
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// TrivialParameterTransform
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// apply
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double TrivialParameterTransform::apply( double original ) const
{
   return original;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// isValid
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool TrivialParameterTransform::isValid( std::string* /*reason*/ ) const
{
   return true;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ConstantParameterTransform
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// apply
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double ConstantParameterTransform::apply( double /*original*/ ) const
{
   return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// isValid
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ConstantParameterTransform::isValid( std::string* /*reason*/ ) const
{
   return true;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// NonTrivialParameterTransformBase
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
NonTrivialParameterTransformBase::NonTrivialParameterTransformBase()
{}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// initialise
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// The initialise method has a couple of calls to virtual functions and therefore the initialisation cannot be done in
/// the constructor.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void NonTrivialParameterTransformBase::initialise( double parameterBoundMin, double parameterBoundMax )
{
   m_parScale = 0.5 * ( parameterBoundMax - parameterBoundMin );
   m_parMin = parameterBoundMin;
   if ( isValid() && !IsEqualTo( parameterBoundMin, parameterBoundMax ) )
   {
      if ( getMonotonicity() == strictlyDecreasing )
      {
         m_resultMin = applyImpl( parameterBoundMax );
         m_resultScale = -2.0 / ( applyImpl( parameterBoundMax ) - applyImpl( parameterBoundMin ) );
      }
      else
      {
         m_resultMin = applyImpl( parameterBoundMin );
         m_resultScale = 2.0 / ( applyImpl( parameterBoundMax ) - applyImpl( parameterBoundMin ) );
      }
   }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// apply
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double NonTrivialParameterTransformBase::apply( double original ) const
{
   double x = ( original + 1 ) * m_parScale;
   x += m_parMin;
   double y = applyImpl( x );

   /// Scale between [-1,1].
   y -= m_resultMin;
   y *= m_resultScale;
   y -= 1.0;

   return y;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LogParameterTransform
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
LogParameterTransform::LogParameterTransform( double parameterBoundMin, double parameterBoundMax )
{
   initialise( parameterBoundMin, parameterBoundMax );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// applyImpl
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double LogParameterTransform::applyImpl( double x ) const
{
   if ( x <= 0 )
   {
      THROW2( ProxyEvaluateError, "Cannot take the log of a negative number or zero." );
   }
   return log( x );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// getMonotonicity
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
NonTrivialParameterTransformBase::Monotonicity LogParameterTransform::getMonotonicity() const
{
   return strictlyIncreasing;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// isValid
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool LogParameterTransform::isValid( std::string* reason ) const
{
   if ( m_parMin <= 0 )
   {
      if ( reason )
      {
         *reason += "Log transform not possible for values smaller than or equal to zero";
      }
      return false;
   }
   return true;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// InverseParameterTransform
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
InverseParameterTransform::InverseParameterTransform( double parameterBoundMin, double parameterBoundMax )
{
   initialise( parameterBoundMin, parameterBoundMax );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// applyImpl
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double InverseParameterTransform::applyImpl( double x ) const
{
   if ( IsEqualTo( x, 0 ) )
   {
      THROW2( ProxyEvaluateError, "Inverse transform not possible for values equal to or very close to zero." );
   }
   return 1 / x;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// getMonotonicity
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
NonTrivialParameterTransformBase::Monotonicity InverseParameterTransform::getMonotonicity() const
{
   return strictlyDecreasing;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// isValid
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool InverseParameterTransform::isValid( std::string* reason ) const
{
   double parMax = m_parMin + m_parScale;
   if ( m_parMin < 0 && parMax > 0 || IsEqualTo( m_parMin, 0 ) || IsEqualTo( parMax, 0 ) )
   {
      if ( reason )
      {
         *reason += "Inverse transform not possible for values equal to or very close to zero";
      }
      return false;
   }
   return true;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// SqrtParameterTransform
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SqrtParameterTransform::SqrtParameterTransform( double parameterBoundMin, double parameterBoundMax )
{
   initialise( parameterBoundMin, parameterBoundMax );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// applyImpl
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double SqrtParameterTransform::applyImpl( double x ) const
{
   if ( x < 0 )
   {
      THROW2( ProxyEvaluateError, "Square root transform not possible for values smaller than zero." );
   }
   return sqrt( x );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// getMonotonicity
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
NonTrivialParameterTransformBase::Monotonicity SqrtParameterTransform::getMonotonicity() const
{
   return strictlyIncreasing;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// isValid
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool SqrtParameterTransform::isValid( std::string* reason ) const
{
   if ( m_parMin < 0 )
   {
      if ( reason )
      {
         *reason += "Square root transform not possible for values smaller than zero";
      }
      return false;
   }
   return true;
}

} /// namespace SUMlib
